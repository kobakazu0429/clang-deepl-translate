%select{return|parameter|variable|field|instance variable|synthesized instance variable}0 type %1 is an abstract class
%1 is a %select{private|protected}0 member of %3
%select{base class|inherited virtual base class}0 %1 has %select{private|protected}3 %select{default |copy |move |*ERROR* |*ERROR* |*ERROR*|}2constructor
calling a %select{private|protected}0 constructor of class %2
calling a %select{private|protected}1 destructor of class %0
base class %0 has %select{private|protected}1 destructor
exception object of type %0 has %select{private|protected}1 destructor
field of type %1 has %select{private|protected}2 destructor
instance variable of type %0 has %select{private|protected}1 destructor
temporary of type %0 has %select{private|protected}1 destructor
variable of type %1 has %select{private|protected}2 destructor
inherited virtual base class %1 has %select{private|protected}2 destructor
field of type %0 has %select{private|protected}2 %select{default |copy |move |*ERROR* |*ERROR* |*ERROR* |}1constructor
friend function %1 is a %select{private|protected}0 member of %3
capture of variable '%0' as type %1 calls %select{private|protected}3 %select{default |copy |move |*ERROR* |*ERROR* |*ERROR* |}2constructor
address of overloaded function %0 is ambiguous
cannot form member pointer of type %0 without '&' and class name
address of overloaded function %0 does not match required type %1
address of overloaded function %0 cannot be converted to type %1
cannot take address of function %0 because parameter %1 has pass_object_size attribute
conflicting address space qualifiers are provided between types %0 and %1
'delete' cannot delete objects of type %0 in address space '%1'
'new' cannot allocate objects of type %0 in address space '%1'
cannot take address of function %0 because its constraints are not satisfied
cannot take address of function %0 because it has one or more non-tautological enable_if conditions
TLS model '%0' is not yet supported on AIX
alias definition of %0 after tentative definition
definition %0 cannot also be an %select{alias|ifunc}1
%0 attribute cannot be applied to a %select{function parameter|variable with 'register' storage class|'catch' variable|bit-field}1
redeclaration has different alignment requirement (%1 vs %0)
%0 must be specified on definition if it is specified on any declaration
requested alignment is less than minimum alignment of %1 for type %0
aligned %select{allocation|deallocation}0 function of type '%1' is %select{only|not}4 available on %2%select{ %3 or newer|}4
requested alignment must be %0 or smaller
requested alignment must be %0 or greater
allocating an object of abstract class type %0
ambiguous cast from base %0 to derived %1:%2
ambiguous conversion of delete expression of type %0 to a pointer
ambiguous conversion from derived class %0 to base class %1:%2
constructor of %0 inherited from multiple base class subobjects
member %0 found in multiple base classes of different types
non-static member %0 found in multiple base-class subobjects of type %1:%2
ambiguous conversion from pointer to member of %select{base|derived}0 class %1 to pointer to member of %select{derived|base}0 class %2:%3
reference to %0 is ambiguous
multiple suitable %0 functions in %1
a type named %0 is hidden by a declaration in a different namespace
anonymous bit-field has negative width (%0)
anonymous %select{struct|union}0 can only contain non-static data members
member of anonymous %select{struct|union}0 redeclares %1
anonymous %select{struct|union}0 cannot contain a %select{private|protected}1 data member
functions cannot be declared in an anonymous %select{struct|union}0
static members cannot be declared in an anonymous %select{struct|union}0
types cannot be declared in an anonymous %select{struct|union}0
anonymous %select{structs|structs and classes}0 must be %select{struct or union|class}0 members
%select{x86|x86-64}0 'interrupt' attribute only applies to functions that have %select{a 'void' return type|only a pointer parameter optionally followed by an integer parameter|a pointer as the first parameter|a %2 type as the second parameter}1
existing instance variable %1 for property %0 with %select{unsafe_unretained|assign}2 attribute must be __unsafe_unretained
cannot perform atomic operation on a pointer to type %0: type has non-trivial ownership
cannot capture __autoreleasing variable in a %select{block|lambda by copy}0
%select{__block variables|global variables|fields|instance variables}0 cannot have __autoreleasing ownership
incompatible types casting %0 to %1 with a %select{__bridge|__bridge_transfer|__bridge_retained}2 cast
cast of %select{Objective-C|block|C}0 pointer type %1 to %select{Objective-C|block|C}2 pointer type %3 cannot use %select{__bridge|__bridge_transfer|__bridge_retained}4
%select{cast|implicit conversion}0 of %select{Objective-C|block|C}1 pointer type %2 to %select{Objective-C|block|C}3 pointer type %4 requires a bridged cast
collection expression type %0 is a forward declaration
%select{implicit conversion|cast}0 of weak-unavailable object of type %1 to a __weak object of type %2
ARC forbids explicit message send of %0
ARC forbids %select{implementation|synthesis}0 of %1
ARC forbids use of %0 in a @selector
%select{|unsafe_unretained|strong|weak}1 property %0 may not also be declared %select{|__unsafe_unretained|__strong|__weak|__autoreleasing}2
%select{pointer|reference}1 to non-const type %0 with no explicit ownership
method was declared as %select{an 'alloc'|a 'copy'|an 'init'|a 'new'}0 method, but its implementation doesn't match because %select{its result type is not an object pointer|its result type is unrelated to its receiver type}1
no visible @interface for %0 declares the selector %1
no known %select{instance|class}1 method for selector %0
%select{implicit conversion|cast}0 of %select{%2|a non-Objective-C pointer type %2|a block pointer|an Objective-C pointer|an indirect pointer to an Objective-C pointer}1 to %3 is disallowed with ARC
multiple methods named %0 found with mismatched result, parameter type or attributes
'new' cannot allocate an array of %0 with no explicit ownership
passing address of %select{non-local|non-scalar}0 object to __autoreleasing parameter for write-back
pseudo-destructor destroys object of type %0 with inconsistently-qualified type %1
receiver %0 for class message is a forward declaration
receiver type %0 for instance message is a forward declaration
existing instance variable %1 for strong property %0 may not be %select{|__unsafe_unretained||__weak}2
thread-local variable has non-trivial ownership: type is %0
incompatible pointer types passing retainable parameter of type %0to a CF function expecting %1 type
synthesizing __weak instance variable of type %0, which does not support weak references
argument value %0 is outside the valid range [%1, %2]
argument %0 value should represent a contiguous bit field
argument should be a multiple of %0
arithmetic on pointer to interface %0, which is not a constant size for this architecture and platform
coprocessor %0 must be configured as %select{GCP|CDE}1
array designator range [%0, %1] is empty
array designator value '%0' is negative
array designator cannot initialize non-array type %0
array designator index (%0) exceeds array bounds (%1)
array has %select{incomplete|sizeless}0 element type %1
cannot initialize array %diff{of type $ with array of type $|with different type of array}0,1
cannot initialize array %diff{of type $ with non-constant array of type $|with different type of array}0,1
array initializer must be an initializer list%select{| or string literal| or wide string literal}0
%select{|ISO C++20 does not permit }0initialization of char array with UTF-8 string literal%select{ is not permitted by '-fchar8_t'|}0
array of abstract class type %0
ambiguous conversion of array size expression of type %0 to an integral or enumeration type
array size expression of type %0 requires explicit conversion to type %1
array size expression has incomplete class type %0
size of array has non-integer type %0
array size expression must have integral or %select{|unscoped }0enumeration type, not %1
%0 used in non-outermost array type derivation
%0 used in array declarator outside of function prototype
array is too large (%0 elements)
automatic variable qualified with an%select{| invalid}0 address space
asm operand has incomplete type %0
more than one input constraint matches the same output '%0'
register '%0' unsuitable for global register variables on this target
invalid input constraint '%0' in asm
invalid input size for constraint '%0'
invalid lvalue in asm input for constraint '%0'
invalid output constraint '%0' in asm
invalid output size for constraint '%0'
reference to a %select{bit-field|vector element|global register variable}0 in asm %select{input|output}1 with a memory constraint '%2'
size of register '%0' does not match variable size
unsupported inline asm: input with type %diff{$ matching output with type $|}0,1
asm constraint has an unexpected number of alternatives: %0 vs %1
unknown register name '%0' in asm
type %0 in generic association compatible with previously specified type %1
type %0 in generic association incomplete
type %0 in generic association not an object type
type %0 in generic association is a variably modified type
address argument to atomic builtin cannot be const-qualified (%0 invalid)
address argument to atomic builtin must be a pointer (%0 invalid)
address argument to atomic builtin must be a pointer to integer, floating-point or pointer (%0 invalid)
address argument to atomic builtin must be a pointer to integer or pointer (%0 invalid)
address argument to atomic builtin must be a pointer to 1,2,4,8 or 16 byte type (%0 invalid)
address argument to load or store exclusive builtin must be a pointer to 1,2,4 or 8 byte type (%0 invalid)
atomic %select{load|store}0 requires runtime support that is not available for this target
address argument to atomic operation must be a pointer to _Atomic type (%0 invalid)
address argument to atomic operation must be a pointer to %select{|atomic }0integer (%1 invalid)
address argument to atomic operation must be a pointer to %select{|atomic }0integer or pointer (%1 invalid)
address argument to atomic operation must be a pointer to %select{|atomic }0integer, pointer or supported floating point type (%1 invalid)
address argument to atomic operation must be a pointer to non-%select{const|constant}0 _Atomic type (%1 invalid)
address argument to atomic operation must be a pointer to non-const type (%0 invalid)
address argument to atomic operation must be a pointer to a trivially-copyable type (%0 invalid)
atomic property of reference type %0 cannot have non-trivial assignment operator
_Atomic cannot be applied to %select{incomplete |array |function |reference |atomic |qualified |sizeless ||integer }0type %1 %select{|||||||which is not trivially copyable|}0
@protocol is using a forward protocol declaration of %0
%0 attribute expression never produces a constant expression
the type %0 is already explicitly ownership-qualified
%0 attribute can only be applied to a %select{function|method}1 with an error parameter
%0 attribute with '%1' convention can only be applied to a %select{function|method}2 returning %select{an integral type|a pointer}3
address space is larger than the maximum supported (%0)
requested alignment must be %0 bytes or smaller
%0 attribute argument is invalid: %select{max must be 0 since min is 0|min must not be greater than max}1
%0 attribute must be greater than 0
%0 attribute requires parameter %1 to be %select{int or bool|an integer constant|a string|an identifier|a constant expression}2
%0 attribute parameter %1 is out of bounds
%0 attribute parameter %1 is out of bounds: %plural{0:no parameters to index into|1:can only be 1, since there is one parameter|:must be between 1 and %2}2
%0 attribute requires integer constant between %1 and %2 inclusive
%0 attribute requires %select{int or bool|an integer constant|a string|an identifier}1
%0 is only supported when '-msve-vector-bits=<bits>' is specified with a value of 128, 256, 512, 1024 or 2048.
invalid SVE vector size '%0', must match value set by '-msve-vector-bits' ('%1')
%0 attribute can only be applied to a ARM or RISC-V builtin
'cleanup' argument %select{|%1 |%1 }0is not a %select{||single }0function
'cleanup' function %0 parameter has %diff{type $ which is incompatible with type $|incompatible type}1,2
'cleanup' function %0 must take 1 parameter
'__declspec(dllexport)' cannot be applied to more than one default constructor in %0
attribute %q0 cannot be applied to a deleted function
lambda cannot be declared %0
attribute %q0 cannot be applied to member of %q1 class
%q0 must have external linkage when declared %q1
redeclaration of %q0 cannot add %q1 attribute
%q0 cannot be thread local when declared %q1
%0 attribute argument may only refer to a function parameter of integer type
%select{a reference type|an array type|a non-vector or non-vectorizable scalar type}0 is an invalid argument to attribute %1
%0 attribute is invalid for the implicit this argument
invalid matrix element type %0
%0 attribute applied to non-SVE type %1
invalid vector element type %0
%0 attribute has no effect on defaulted or deleted functions
%0 attribute is permitted on definitions only
empty %0 cannot be composed with named ones
%0 attribute cannot be used with pointers to members
function type with %0 attribute must have C linkage
%0 attribute is not supported in %select{C|C++|Objective-C}1
%0 attribute is not supported on '%1'
%0 attribute can only be applied once per parameter
redeclaration of %0 must %select{not |}1have the 'overloadable' attribute
'overloadable' function %0 must have a prototype
%0 attribute only applies to%select{| constant}1 pointer arguments
argument %0 to 'preferred_name' attribute is not a typedef for a specialization of %1
'regparm' parameter must be between 0 and %0 inclusive
%0 attribute requires OpenCL version %1%select{| or above}2
%0 attribute requires a %select{positive|non-negative}1 integral compile time constant expression
argument to %select{'code_seg'|'section'}1 attribute is not valid for this target: %0
%0 size too large
%0 attribute cannot be applied to sizeless type %1
%0 attribute takes at least %1 argument%s1
%0 attribute takes no more than %1 argument%s1
%0 attribute is not supported on targets missing %1; specify an appropriate -march= or -mcpu=
weakref declaration of %0 must be in a global context
weakref declaration of %0 must also have an alias attribute
%0 attribute only applies to %select{functions|unions|variables and functions|functions and methods|functions, methods and blocks|functions, methods, and parameters|variables|variables and fields|variables, data members and tag types|types and namespaces|variables, functions and classes|kernel functions|non-K&R-style functions}1
%0 attribute only applies to %1
%0 attribute %plural{0:takes no arguments|1:takes one argument|:requires exactly %1 arguments}1
zero %0 size
%0 and %1 attributes are not compatible
%select{'auto'|'decltype(auto)'|'__auto_type'|template arguments}0 deduced as %1 in declaration of %2 and deduced as %3 in declaration of %4
cannot deduce return type %0 from returned value of type %1
'%select{auto|decltype(auto)}0' in return type deduced as %1 here but deduced as %2 in earlier return statement
cannot deduce return type %0 for function with no return statements
cannot deduce return type %0 from omitted return expression
function %0 with deduced return type cannot be used before it is defined
deduced conflicting types %diff{($ vs $) |}0,1for initializer list element type
new expression for type %0 contains multiple constructor arguments
new expression for type %0 has incompatible constructor argument of type %1
new expression for type %0 requires a constructor argument
%select{function with deduced return type|declaration with trailing return type}0 must be the only declaration in its group
%select{'auto'|'decltype(auto)'|'__auto_type'|use of %select{class template|function template|variable template|alias template|template template parameter|concept|template}2 %3 requires template arguments; argument deduction}0 not allowed %select{in function prototype|in non-static struct member|in struct member|in non-static union member|in union member|in non-static class member|in interface member|in exception declaration|in template parameter until C++17|in block literal|in template argument|in typedef|in type alias|in function return type|in conversion function type|here|in lambda parameter|in type allocated by 'new'|in K&R-style function parameter|in template parameter|in friend declaration|in function prototype that is not a function declaration|in requires expression parameter}1
variable %0 with type %1 has incompatible initializer of type %2
cannot deduce actual type for variable %0 with type %1 from initializer list
initializer for variable %0 with type %1 contains multiple expressions
initializer for variable %0 with type %1 is empty
cannot deduce type for variable %1 with type %2 from %select{parenthesized|nested}0 initializer list
declaration of variable %0 with deduced type %1 requires an initializer
variable %0 declared with deduced type %1 cannot appear in its own initializer
return type of 'await_suspend' is required to be 'void' or 'bool' (have %0)
%0 is an incomplete type
property implementation must have its declaration in the category %0
%select{const_cast||||C-style cast|functional-style cast|}0 to %2, which is not a reference, pointer-to-object, or pointer-to-data-member
address of overloaded function %0 cannot be cast to type %1
%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|addrspace_cast}0 from %1 to %2 converts between mismatching address spaces
%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from bit-field lvalue to reference type %2
%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|addrspace_cast}0 from %1 to %2 is not allowed
cannot %select{||reinterpret_cast||C-style cast||}0 from member pointer type %1 to member pointer type %2 of different size
%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2 casts away qualifiers
%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|addrspace_cast}0 from rvalue to reference type %2
%select{||reinterpret_cast||C-style cast||}0 from scalar %1 to vector %2 of different size
%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2, which are not related by inheritance, is not allowed
%select{||reinterpret_cast||C-style cast||}0 from vector %1 to scalar %2 of different size
%select{||reinterpret_cast||C-style cast||}0 from vector %1 to vector %2 of different size
%0 is not a class type
%0 is not polymorphic
cannot use dynamic_cast to convert from %0 to %1
invalid target type %0 for dynamic_cast; target type must be a reference or pointer type to a defined class
%0 cannot be used as the type of a kernel parameter
cannot cast from lvalue of type %1 to rvalue reference type %2; types are not compatible
left hand operand to %0 must be a %select{|pointer to }1class compatible with the right hand operand, but is %2
right hand operand to %0 has non-pointer-to-member type %1
function multiversioning doesn't support %select{feature|architecture}0 '%1'
cannot allocate %select{function|reference}1 type %0 with new
%0 cannot be the name of a parameter
property implementation must have its declaration in interface %0 or one of its extensions
bad receiver type %0
reinterpret_cast cannot resolve overloaded function %0 to type %1
reinterpret_cast of a %0 to %1 needs its address, which is not allowed
cast from pointer to smaller type %2 loses information
cannot cast from rvalue of type %1 to rvalue reference type %2; types are not compatible
cannot cast from type %1 to member pointer type %2
address of overloaded function %0 cannot be static_cast to type %1
cannot cast from type %1 to pointer type %2
%0 cannot be the name of a variable or data member
base class %0 has a flexible array member
base class initializer %0 names both a direct base class and an inherited virtual base class
constructor initializer %0 does not name a class
%0 attribute cannot be applied to a base specifier
binding %0 cannot appear in the initializer of its own decomposition declaration
__builtin_bit_cast %select{source|destination}0 type must be trivially copyable
__builtin_bit_cast source size does not equal destination size (%0 vs %1)
bit-field %0 has negative width (%1)
named bit-field %0 has zero width
%select{bit-field %1|anonymous bit-field}0 is too wide (%2 bits)
width of%select{ anonymous|}0 bit-field%select{| %1}0 (%2 bits) exceeds the %select{width|size}3 of its type (%4 bit%s4)
block cannot return %select{array|function}0 type %1
blocks support disabled - compile with -fblocks or %select{pick a deployment target that supports them|for OpenCL 2.0}0
reference to non-static member function must be called%select{|; did you mean to call it with no arguments?}0
%select{string|character|boolean|numeric}0 literal must be prefixed by '@' in a collection
__builtin_btf_type_id argument %0 not a constant
definition of builtin function %0
%select{non-pointer|function pointer|void pointer}0 argument to '__builtin_launder' is not allowed
%0 dimension is outside the allowed range [1, %1]
%ordinal0 argument must be a pointer to a valid matrix element type
the pointee of the 2nd argument must match the element type of the 1st argument (%0 != %1)
%0 argument must be a constant unsigned integer expression
call to '%select{__builtin_operator_new|__builtin_operator_delete}0' selects non-usual %select{allocation|deallocation}0 function
cannot redeclare builtin function %0
'%0' is only available in %1
%select{qualifier in |static |}0array size %select{||'[*] '}0is a C99 feature, not permitted in C++
calling %0 with incomplete return type %1
argument type %0 is incomplete
calling function with incomplete return type %0
'callback' attribute argument %0 is not a known function parameter
'callback' argument at position %0 references unavailable implicit 'this'
cannot find suitable %select{getter|setter}0 for property %1
cannot form a pointer-to-member to member %0 of reference type %1
cannot pass non-trivial C object of type %0 by value to variadic %select{function|block|method|constructor}1
cannot pass object with interface type %0 by value through variadic %select{function|block|method|constructor}1
cannot pass object with interface type %1 by value to variadic %select{function|block|method|constructor}2; expected type from format string was %3
cannot pass %select{expression of type %1|initializer list}0 to variadic %select{function|block|method|constructor}2
cannot pass %select{expression of type %1|initializer list}0 to variadic %select{function|block|method|constructor}2; expected type from format string was %3
capture host variable %0 by reference in device or host device lambda function
__block variable %0 cannot be captured in a %select{lambda expression|captured statement}1
%0 in capture list does not name a variable
%0 can appear only once in a capture list
%0 cannot be captured because it does not have automatic storage duration
by-copy capture of value of abstract type %0
by-copy capture of variable %0 with %select{incomplete|sizeless}1 type %2
%select{function|parameter}0 declared '[[carries_dependency]]' after its first declaration
operand of type %0 cannot be cast to a pointer type
pointer cannot be cast to type %0
cannot catch incomplete type %0
cannot catch pointer to incomplete type %0
cannot catch reference to incomplete type %0
cannot catch %select{|reference to }0sizeless type %1
cannot catch variably modified type %0
cannot define %select{category|class extension}0 for undefined class %1
property declared in category %0 cannot be implemented in class implementation
function declared '%0' here was previously declared %select{'%2'|without calling convention}1
parameter %0 must have a complete type to use function %1 with the %2 calling convention
function with no prototype cannot use the %0 calling convention
variadic function cannot use %0 calling convention
circular inheritance between %0 and %1
cannot declare class extension for %0 after class implementation
base %0 is marked '%select{final|sealed}1'
property %0 is a class property; did you mean to access it with class '%1'?
%0 redeclared with '%1' access
the type %0 is not a pointer to a fast-enumerable object
%select{block pointer|pointer|reference}0 to function type %select{%2 |}1cannot have '%3' qualifier
operands to conditional of types%diff{ $ and $|}0,1 are incompatible in ARC mode
conditional expression is ambiguous; %diff{$ can be converted to $ and vice versa|types can be convert to each other}0,1
conditional expression is ambiguous; %diff{$ and $|types}0,1 can be converted to several common types
vector condition type %0 and result type %1 do not have elements of the same size
GNU vector conditional operand cannot be %select{void|a throw expression}0
vector operands to the vector conditional must be the same type %diff{($ and $)|}0,1}
enumeration type %0 is not allowed in a vector conditional
vector condition type %0 and result type %1 do not have the same number of elements
%select{left|right}1 operand to ? is void, but %select{right|left}1 operand is of type %0
CUDA special function '%0' must have scalar return type
conflicting types for alias %0
instance variable %0 has conflicting bit-field width
conflicting instance variable names: %0 vs %1
instance variable %0 has conflicting type%diff{: $ vs $|}1,2
virtual function %0 has different calling convention attributes %diff{($) than the function it overrides (which has calling convention $)|than the function it overrides}1,2
conflicting super class name %0
conflicting types for %0
argument to %0 must be a constant integer
consteval function %0 cannot override a non-consteval function
statement not allowed in %select{constexpr|consteval}1 %select{function|constructor}0
no return statement in %select{constexpr|consteval}0 function
destructor cannot be declared %sub{select_constexpr_spec_kind}0
destructor cannot be declared %sub{select_constexpr_spec_kind}0 because %select{data member %2|base class %3}1 does not have a constexpr destructor
variable of non-literal type %1 cannot be defined in a constexpr %select{function|constructor}0
%select{static|thread_local}1 variable not permitted in a constexpr %select{function|constructor}0
'main' is not allowed to be declared %select{constexpr|consteval}0
%select{constexpr|consteval}2 %select{function|constructor}1's %ordinal0 parameter type %3 is not a literal type
%select{constexpr|consteval}0 function's return type %1 is not a literal type
%select{non-constexpr|constexpr|consteval}1 declaration of %0 follows %select{non-constexpr|constexpr|consteval}2 declaration
non-void %select{constexpr|consteval}1 function %0 should return a value
declaration of constexpr static data member %0 requires an initializer
%select{class|struct|interface|union|enum}0 cannot be marked %sub{select_constexpr_spec_kind}1
constexpr variable cannot have non-literal type %0
constexpr variable %0 must have constant destruction
constexpr variable %0 must be initialized by a constant expression
constexpr %select{member function|constructor}0 not allowed in %select{struct|interface|class}1 with virtual base %plural{1:class|:classes}2
variably-modified type %0 cannot be used in a constexpr %select{function|constructor}1
%sub{select_constexpr_spec_kind}0 can only be used in %select{|variable and function|function|variable}0 declarations
constructor cannot be declared '%0'
cannot specify any part of a return type in the declaration of a conversion function%select{; put the complete type after 'operator'|; use a typedef to declare a conversion to %1|; use an alias template to declare a conversion to %1|}0
std::experimental::coroutine_handle missing a member named '%0'
'%1' cannot be used in %select{a constructor|a destructor|the 'main' function|a constexpr function|a function with a deduced return type|a varargs function|a consteval function}0
'%0' cannot be used outside a function
%0: 'get_return_object_on_allocation_failure()' must be a static member function
the coroutine promise type %0 declares both 'return_value' and 'return_void'
%0 is required to have a non-throwing noexcept specification when the promise type declares 'get_return_object_on_allocation_failure()'
the coroutine promise type %0 must declare either 'return_value' or 'return_void'
this function cannot be a coroutine: %0 is an incomplete type
%0 is required to declare the member 'unhandled_exception()'
this function cannot be a coroutine: missing definition of specialization %0
'%0' cannot be used in an unevaluated context
'%0' cannot be used in the handler of a try block
return type of virtual function %3 is not covariant with the return type of the function it overrides (ambiguous conversion from derived class %0 to base class %1:%2)
invalid covariant return for virtual function: %1 is a %select{private|protected}2 base class of %0
return type of virtual function %0 is not covariant with the return type of the function it overrides (%1 is incomplete)
return type of virtual function %0 is not covariant with the return type of the function it overrides (%1 is not derived from %2)
return type of virtual function %0 is not covariant with the return type of the function it overrides (class type %1 is more qualified than class type %2
return type of virtual function %0 is not covariant with the return type of the function it overrides (%1 has different qualifiers than %2)
multiple 'cpu_specific' functions cannot specify the same CPU: %0
%select{constructor|destructor}1 %0 must not return void expression
illegal device builtin %select{surface|texture}0 reference class template %1 declared here
illegal device builtin %select{surface|texture}0 reference type %1 declared here
cannot use '%0' in %select{__device__|__global__|__host__|__host__ __device__}1 function
__shared__ variable %0 cannot be 'extern'
__shared__ local variables not allowed in %select{__device__|__global__|__host__|__host__ __device__}0 functions
%select{__device__|__global__|__host__|__host__ __device__}0 function %1 cannot overload %select{__device__|__global__|__host__|__host__ __device__}2 function %3
constexpr function %0 without __host__ or __device__ attributes cannot overload __device__ function with same signature.  Add a __host__ attribute, or build with -fno-cuda-host-device-constexpr.
cannot use variable-length arrays in %select{__device__|__global__|__host__|__host__ __device__}0 functions
module name '%0' specified on command line does not match name of module
%select{reference|backing array for 'std::initializer_list'}2 %select{|subobject of }1member %0 %select{binds to|is}2 a temporary object whose lifetime would be shorter than the lifetime of the constructed object
dealloc return type must be correctly specified as 'void' under ARC, instead of %0
%0 attribute cannot be applied to a statement
'%0' declared as an array with a negative size
cannot form %select{pointer to|reference to|array of}0 'decltype(auto)'
cannot decompose members of ambiguous base class %1 of %0:%2
cannot decompose class type %0 because it has an anonymous %select{struct|union}1 member
cannot decompose members of inaccessible base class %1 of %0
cannot decompose %select{private|protected}0 member %1 of %3
cannot decompose class type %1: %select{its base classes %2 and|both it and its base class}0 %3 have non-static data members
decomposition declaration %0 requires an initializer
decomposition declaration cannot be declared %plural{1:'%1'|:with '%1' specifiers}0
cannot decompose this type; 'std::tuple_element<%0>::type' does not name a type
cannot decompose this type; 'std::tuple_size<%0>::value' is not a valid integral constant expression
decomposition declaration cannot be declared with type %0; declared type must be 'auto' or reference to 'auto'
cannot decompose %select{union|non-class, non-array}1 type %2
type %0 decomposes into %3 %plural{1:element|:elements}2, but %select{%plural{0:no|:only %1}1|%1}4 %plural{1:name was|:names were}1 provided
cannot %select{form pointer to|form reference to|form array of|form function returning|use parentheses when declaring variable with}0 deduced class template specialization type
ambiguous deduction for template arguments of %0
no viable constructor or deduction guide for deduction of template arguments of %0
class template argument deduction for %0 selected a deleted constructor
class template argument deduction for %0 selected an explicit %select{constructor|deduction guide}1 for copy-list-initialization
template %0 has no definition and no %select{|viable }1deduction guides for deduction of template arguments
%select{<error>|function template|variable template|alias template|template template parameter|concept|template}0 %1 requires template arguments; argument deduction only allowed for class templates
deduced non-type template argument does not have the same type as the corresponding template parameter%diff{ ($ vs $)|}0,1
typename specifier refers to %select{class template|function template|variable template|alias template|template template parameter|template}0; argument deduction not allowed here
deduced type %1 of deduction guide is not %select{|written as }2a specialization of template %0
deduction guide cannot be declared '%0'
cannot specify deduction guide for %select{<error>|function template|variable template|alias template|template template parameter|concept|dependent template name}0 %1
deduction guide cannot be %select{explicitly instantiated|explicitly specialized}0
deduction guide template contains %select{a template parameter|template parameters}0 that cannot be deduced
deduction guide must be declared in the same scope as template %q0
exception specifications of %select{return|argument}0 types differ
addition of default argument on redeclaration makes this constructor a %select{default|copy|move}0 constructor
default initialization of an object of const type %0%select{| without a user-provided default constructor}1
default member initializer for %0 uses itself
default member initializer for %1 needed within definition of enclosing class %0 outside of member functions
return type of defaulted 'operator<=>' cannot be deduced because three-way comparison for %select{|member|base class}0 %1 has a deduced return type and is not yet defined
deduced return type for defaulted %sub{select_defaulted_comparison_kind}0 must be 'auto', not %1
defaulted member %sub{select_defaulted_comparison_kind}0 must be const-qualified
%sub{select_defaulted_comparison_kind}0 can only be defaulted in a class definition
invalid parameter type for defaulted %sub{select_defaulted_comparison_kind}0; found %1, expected %2%select{| or %4}3
parameters for defaulted %sub{select_defaulted_comparison_kind}0 must have the same type%diff{ (found $ vs $)|}1,2
return type for defaulted %sub{select_defaulted_comparison_kind}0 must be 'bool', not %1
the parameter for this explicitly-defaulted copy %select{constructor|assignment operator}0 is const, but a member or base requires it to be non-const
the parameter for an explicitly-defaulted move %select{constructor|assignment operator}0 may not be const
an explicitly-defaulted %select{|copy |move }0constructor cannot have default arguments
an explicitly-defaulted %select{copy|move}0 assignment operator may not have 'const'%select{, 'constexpr'|}1 or 'volatile' qualifiers
explicitly-defaulted %select{copy|move}0 assignment operator must return %1
an explicitly-defaulted %select{|copy |move }0constructor cannot be variadic
the parameter for an explicitly-defaulted %sub{select_special_member_kind}0 may not be volatile
definition of explicitly defaulted %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor|function}0
definition of implicitly declared %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor|function}1
converting delete expression from type %0 to type %1 invokes an explicit conversion function
deleting incomplete class type %0; no conversions to pointer type
cannot delete expression of type %0
constructor inherited by %0 from base class %1 is implicitly deleted
deleted function %0 cannot override a non-deleted function
typename specifier refers to %select{class template|function template|variable template|alias template|template template parameter|template}0 member in %1; argument deduction not allowed here
%select{declaration|definition}0 of %select{struct|interface|union|class|enum}1 in a dependent scope
non-type template argument specializes a template parameter with dependent type %0
dereference of pointer to incomplete type %0
designator in initializer for %select{scalar|indivisible sizeless}0 type %1
%select{no_destroy|always_destroy}0 attribute can only be applied to a variable with static or thread storage duration
destructor cannot be declared '%0'
identifier %0 in object destruction expression does not name the type %1 of the object being destroyed
identifier %0 in object destruction expression does not name a type
destructor type %0 in object destruction expression does not match the type %1 of the object being destroyed
identifier %0 after '~' in destructor name does not name a type
%0 requires %select{|%2 bit size}1 %3 type support, but device '%4' does not support it
%0
declaration of %0 has a different language linkage
virtual function %0 has a different return type %diff{($) than the function it overrides (which has return type $)|than the function it overrides}1,2
@selector expression formed with direct selector %0
cannot cast %select{private|protected}2 base class %1 to %0
reference to %select{destructor|pseudo-destructor}0 must be called%select{|; did you mean to call it with no arguments?}1
reimplementation of category %1 for class %0
reimplementation of class %0
base class %0 specified more than once as a direct base class
duplicate case value '%0'
duplicate case value: '%0' and '%1' both equal '%2'
duplicate interface definition for class %0
synthesized properties %0 and %1 both claim instance variable %2
duplicate member %0
duplicate declaration of method %0
initializer for sizeless type %0 cannot be empty
non-integral type %0 is an invalid underlying type
mode %0 is not supported for enumeration types
enumeration previously declared with %select{non|}0fixed underlying type
enumeration previously declared as %select{un|}0scoped
enumeration redeclared with different underlying type %0 (was %1)
enumerator %0 does not exist in instantiation of %1
enumerator value is not representable in the underlying type %0
enumerator value %0 is not representable in the underlying type %1
exception specification of %0 uses itself
exception specifications are not allowed in %select{typedefs|type aliases}0
exception specification needed for member of incomplete class %0
cannot use '%0' with exceptions disabled
excess elements in %select{array|vector|scalar|union|struct}0 initializer
excess elements in initializer for indivisible sizeless type %0
%0 is not a class%select{ or namespace|, namespace, or enumeration}1
partial ordering for explicit instantiation of %0 is ambiguous
explicit instantiation refers to static data member %q0 that is not an instantiation
duplicate explicit instantiation of %0
explicit instantiation of %0 in class scope
explicit instantiation declaration of %0 with internal linkage
explicit instantiation refers to member function %q0 that is not an instantiation
explicit instantiation of %0 must occur at global scope
explicit instantiation of non-templated type %0
explicit instantiation of %0 does not refer to a function template, variable template, member function, member class, or static data member
explicit instantiation of typedef %0
explicit instantiation of %0 not in a namespace enclosing %1
explicit instantiation of undefined function template %0
explicit instantiation of undefined %select{member class|member function|static data member}0 %1 of class template %2
explicit instantiation of undefined variable template %q0
explicit instantiation of %q0 must occur in namespace %1
explicit instantiation of %q0 must specify a template argument list
explicit specialization has extraneous, inconsistent storage class '%select{none|extern|static|__private_extern__|auto|register}0'
declaration of %0 with internal linkage cannot be exported
%select{empty|static_assert|asm}0 declaration cannot be exported
export declaration can only be used within a module interface unit%select{ after the module declaration|}0
using declaration referring to %0 with internal linkage cannot be exported
%select{case value|enumerator value|non-type template argument|array size|explicit specifier argument}0 is not a constant expression
expression is not an %select{integer|integral}0 constant expression
%select{signed|unsigned}0 _ExtInt must have a bit size of at least %select{2|1}0
%select{signed|unsigned}0 _ExtInt of bit sizes greater than %1 not supported
vector component access exceeds type %0
illegal vector component name '%0'
declaration of %1 %select{with C language linkage|in global scope}0 conflicts with declaration %select{in global scope|with C language linkage}0
extern declaration of %0 follows non-extern declaration
%0 attribute is only allowed on empty statements
field %0 declared as a function
field designator cannot initialize a %select{non-struct, non-union|non-class}0 type %1
field designator %0 does not refer to a non-static data member
field designator %0 does not refer to any field in type %1
field designator %0 does not refer to any field in type %1; did you mean %2?
field has %select{incomplete|sizeless}0 type %1
data member instantiated with function type %0
filter expression has non-integral type %0
declaration of %0 overrides a '%select{final|sealed}1' function
first argument to 'va_arg' is of type %0 and not 'va_list'
flexible array member %0 not allowed in otherwise empty %select{struct|interface|union|class|enum}1
flexible array member %0 of type %1 with non-trivial destruction
flexible array member %0 with type %1 is not at the end of %select{struct|interface|union|class|enum}2
flexible array member %0 in a union is not allowed
flexible array member %0 not allowed in %select{struct|interface|union|class|enum}1 which has a virtual base class
unary fold expression has empty expansion for operator '%0' with no fallback value
instantiating fold expression with %0 arguments exceeded expression nesting limit of %1
cannot use type %0 as a range
invalid range expression of type %0; did you mean to dereference it with '*'?
cannot use incomplete type %0 as a range
invalid range expression of type %0; no viable '%select{begin|end}1' function available
cannot use type %0 as an iterator
loop variable %0 may not be declared %select{'extern'|'static'|'__private_extern__'|'auto'|'register'|'constexpr'|'thread_local'}1
format argument not %0
function does not return %0
attempting to use the forward class %0 as superclass of %1
explicit qualification required to use member %0 from dependent base class
member %0 used before its declaration
friend declaration of %0 does not match any declaration in %1
incomplete result type %0 in function definition
function cannot return %select{array|function}0 type %1
function cannot return qualified void type %0
function declared with %0 attribute was previously declared without the %0 attribute
%0 marked 'override' but does not override any member functions
type %0 of function parameter pack does not contain any unexpanded parameter packs
function template specialization %0 ambiguously refers to more than one function template; explicitly specify%select{| additional}1 template arguments to identify a particular function template
no function template matches function template specialization %0
controlling expression type %0 compatible with %1 generic association types
controlling expression type %0 not compatible with any generic association type
call to global function %0 not configured
cannot jump from this goto statement to label %0 inside an inline assembly block
invalid type %0 as argument of iboutletcollection attribute
ambiguous conversion from type %0 to an integral or unscoped enumeration type
integral constant expression requires explicit conversion from %0 to %1
integral constant expression has incomplete class type %0
%select{integer|integral}1 constant expression must have %select{integer|integral or unscoped enumeration}1 type, not %0
integer constant expression evaluates to value %0 that cannot be represented in a %1-bit %select{signed|unsigned}2 integer type
'%0' declared as array of %1
'%0' declared as array of functions of type %1
'%0' declared as array of references of type %1
'%0' does not point into a class
'%0' declared as a member pointer to a reference of type %1
'%0' declared as a member pointer to void
'%0' declared as a pointer to a reference of type %1
illegal initializer type %0
Objective-C message has incomplete result type %0
%select{anonymous struct|union}0 member %1 has a non-trivial %sub{select_special_member_kind}2
implicit conversion from %0 to %1 is not permitted in C++
implicit instantiation of undefined member %0
cannot %select{use builtin operator '<=>'|default 'operator<=>'}1 because type '%0' was not found; include <compare>
%0 type was not found; include <experimental/coroutine> before defining a coroutine
this function cannot be a coroutine: %0 is not a class
this function cannot be a coroutine: %q0 has no member named 'promise_type'
static data member of type %0 must be initialized out of line
in-class initializer for static data member of type %0 requires 'constexpr' specifier
%select{%diff{assigning to $ from incompatible type $|assigning to type from incompatible type}0,1|%diff{passing $ to parameter of incompatible type $|passing type to parameter of incompatible type}0,1|%diff{returning $ from a function with incompatible result type $|returning type from a function with incompatible result type}0,1|%diff{converting $ to incompatible type $|converting type to incompatible type}0,1|%diff{initializing $ with an expression of incompatible type $|initializing type with an expression of incompatible type}0,1|%diff{sending $ to parameter of incompatible type $|sending type to parameter of incompatible type}0,1|%diff{casting $ to incompatible type $|casting type to incompatible type}0,1}2
incompatible vector types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2
enumeration %0 is incomplete
%select{|pointer to |reference to }0incomplete type %1 is not allowed in exception specification
member access into incomplete type %0
incomplete type %0 named in nested name specifier
incomplete type in call to object of type %0
incomplete receiver type %0
cannot synthesize property %0 with incomplete type %1
incomplete type %0 where a complete type is required
'@encode' of incomplete type %0
incomplete type %0 used in type trait expression
'typeid' of incomplete type %0
defaulted definition of %select{%sub{select_defaulted_comparison_kind}1|three-way comparison operator}0 cannot be declared %select{constexpr|consteval}2 because %select{it|the corresponding implicit 'operator=='}0 invokes a non-constexpr comparison function
defaulted declaration of %sub{select_special_member_kind}0 cannot be consteval because implicit definition is not constexpr
defaulted definition of %sub{select_special_member_kind}0 is not constexpr
cannot %select{decrement|increment}0 expression of enum type %1
cannot jump from this %select{indirect|asm}0 goto statement to one of its possible targets
cannot deduce type for lambda capture %0 from initializer of type %2
cannot deduce type for lambda capture %0 from initializer list
initializer for lambda capture %0 contains multiple expressions
initializer missing for lambda capture %0
cannot deduce type for lambda capture %1 from %select{parenthesized|nested}0 initializer list
cannot initialize %select{a variable|a parameter|template parameter|return object|statement expression result|an exception object|a member subobject|an array element|a new value|a value|a base class|a constructor delegation|a vector element|a block element|a block element|a complex element|a lambda capture|a compound literal initializer|a related result|a parameter of CF audited function}0 %diff{of type $ with an %select{rvalue|lvalue}2 of type $|with an %select{rvalue|lvalue}2 of incompatible type}1,3%select{|: different classes%diff{ ($ vs $)|}5,6|: different number of parameters (%5 vs %6)|: type mismatch at %ordinal5 parameter%diff{ ($ vs $)|}6,7|: different return type%diff{ ($ vs $)|}5,6|: different qualifiers (%5 vs %6)|: different exception specifications}4
cannot create object of function type %0
initialization of incomplete type %0
%select{|non-aggregate }0type %1 cannot be initialized with an initializer list
init methods must return an object pointer type, not %0
initialization of non-aggregate type %0 with an initializer list
cannot initialize Objective-C class type %0
reference member of type %0 uninitialized
initializer would partially override prior initialization of object of type %1 with non-trivial destruction
inline declaration of %0 follows non-inline definition
inline declaration of %0 not allowed in block scope
'inline' can only appear on functions%select{| and non-local variables}0
invalid block pointer conversion %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2
'internal_linkage' attribute does not appear on the first declaration of %0
%plural{[0,2]:must use a qualified name when declaring|3:cannot declare}0 a %select{constructor|destructor|conversion operator|deduction guide}0 as a friend
value '%0' out of range for constraint '%1'
invalid reinterpretation: sizes of %0 and %1 must match
%0 attribute cannot be applied to virtual functions
interface type cannot inherit from %select{struct|non-public interface|class}0 %1
invalid or misplaced branch protection specification '%0'
collection element of type %0 is not an Objective-C object
'_Complex %0' is invalid
call to consteval function %q0 is not a constant expression
%0 cannot be declared consteval
cannot take address of consteval function %0 outside of an immediate invocation
%select{function parameter|typedef}0 cannot be %sub{select_constexpr_spec_kind}1
non-static data member cannot be constexpr%select{; did you intend to make it %select{const|static}0?|}1
invalid conversion between ext-vector type %0 and %1
conversion between matrix type %0 and incompatible type %1 is not allowed
conversion between matrix types%diff{ $ and $|}0,1 of different size is not allowed
invalid conversion between vector type %0 and integer type %1 of different size
invalid conversion between vector type %0 and scalar type %1
invalid conversion between vector type%diff{ $ and $|}0,1 of different size
invalid option '%0' for %select{cpu_specific|cpu_dispatch}1
cannot combine with previous '%0' declaration specifier
definition or redeclaration of %0 cannot name the global scope
definition or redeclaration of %0 not allowed inside a block
definition or redeclaration of %0 not allowed inside a function
cannot define or redeclare %0 here because namespace %1 does not enclose namespace %2
invalid use of incomplete type %0
invalid use of member %0 in static member function
invalid use of non-static data member %0
%0 is not a valid literal type for NSNumber
'__pixel' must be preceded by '__vector'.  '%0' declaration specifier not allowed here
%0 is not a valid property name (accessing an object of type %1)
'%0' qualifier is not allowed on a constructor
'%0' qualifier is not allowed on a destructor
%select{non-member function|static member function|deduction guide}0 %select{of type %2 |}1cannot have '%3' qualifier
receiver type %0 is not an Objective-C class
'_Sat' specifier is only valid on '_Fract' or '_Accum', not '%0'
'%0' cannot be signed or unsigned
'%0' is only allowed on variable declarations
the %0 type cannot be used to declare a program scope variable
type %2 of %select{explicit instantiation|explicit specialization|partial specialization|redeclaration}0 of %1 does not match expected type %3
cannot use '%0' with '__vector bool'
cannot combine with previous '%0' declaration specifier. '__vector' must be first
'%select{|short|long|long long}0 %1' is invalid
property %0 not found on object of type %1; did you mean to access instance variable %2?
property %0 attempting to use instance variable %1 declared in super class %2
instance variable %0 accessed in class method
kernel call to non-global function %0
kernel function %0 must be a free function or static member function
kernel function type %0 must have void return type
variable %0 with flexible array member cannot be captured in a lambda expression
variable %0 cannot be implicitly captured in a lambda with no capture-default specified
incomplete result type %0 in lambda expression
cannot apply asm label to %select{variable|function}0 after its first use
'lifetimebound' attribute cannot be applied to a %select{constructor|destructor}0
'lifetimebound' attribute cannot be applied; %select{static |non-}0member function has no implicit object parameter
cannot initialize %select{non-class|reference}0 type %1 with a parenthesized initializer list
non-namespace scope '%0' cannot have a literal operator member
literal operator %0 must be in a namespace or global scope
invalid literal operator parameter type %0, did you mean %1?
variable %0 cannot be declared both 'extern' and with the 'loader_uninitialized' attribute
%select{non-const|volatile}0 lvalue reference to type %1 cannot bind to an initializer list temporary
%select{non-const|volatile}0 lvalue reference %diff{to type $ cannot bind to a temporary of type $|cannot bind to incompatible temporary}1,2
%select{non-const|volatile}0 lvalue reference %diff{to type $ cannot bind to a value of unrelated type $|cannot bind to a value of unrelated type}1,2
rvalue reference %diff{to type $ cannot bind to lvalue of type $|cannot bind to incompatible lvalue}0,1
%select{unknown|unsupported}0 machine mode %1
%select{first|second|third|fourth}0 parameter of 'main' (%select{argument count|argument array|environment|platform-specific data}0) must be of type %1
too many parameters (%0) for 'main': must be 0, 2, or 3
%0 cannot be a template
matrix %select{row|column}0 index is not an integer
matrix %select{row|column}0 index is outside the allowed range [0, %1)
member initializer %0 does not name a non-static data member or base class
initializer %0 does not name a non-static data member or base class; did you mean the %select{base class|member}1 %2?
out-of-line %select{declaration|definition}2 of %0 does not match any declaration in %1
out-of-line %select{declaration|definition}2 of %0 does not match any declaration in %1; did you mean %3?
return type of out-of-line definition of %q0 differs from that in the declaration
out-of-line definition of %0 from class %1 without definition
extra qualification on member %0
'this' argument to member function %0 has type %1, but function is not marked %select{const|restrict|const or restrict|volatile|const or volatile|volatile or restrict|const, volatile, or restrict}2
'this' argument to member function %0 is an %select{lvalue|rvalue}1, but function has %select{non-const lvalue|rvalue}2 ref-qualifier
cannot initialize object parameter of type %0 with an expression of type %1
member %0 has the same name as its class
no member %0 in %1; it has not yet been instantiated
non-friend class member %0 cannot have a qualified name
multiple overloads of %0 instantiate to the same signature %1
base of member reference is a function; perhaps you meant to call it%select{| with no arguments}0?
member pointer refers into non-class type %0
conversion from pointer to member of class %0 to pointer to member of class %1 via virtual base %2 is not allowed
member pointer has incomplete base type %0
at least one argument of MTE builtin function must be a pointer (%0, %1 invalid)
%0 argument of MTE builtin function must be an integer type (%1 invalid)
%0 argument of MTE builtin function must be a pointer (%1 invalid)
%0 argument of MTE builtin function must be a null or a pointer (%1 invalid)
%select{instance|class}1 method %0 not found ; did you mean %2?
inheritance model does not match %select{definition|previous declaration}0
declaration of %0 in %select{the global module|module %2}1 follows declaration in %select{the global module|module %4}3
instance variables may not be placed in %select{categories|class extension}0
%select{string|numeric}0 literal must be prefixed by '@'
%select{constructor for %1 must explicitly initialize the|implicit default constructor for %1 must explicitly initialize the|cannot use constructor inherited from base class %4;}0 %select{base class|member}2 %3 %select{which|which|of %1}0 does not have a default constructor
%0 is missing exception specification '%1'
synthesized property %0 must either be named the same as a compatible instance variable or must explicitly name an instance variable
@import of module '%0' in implementation of '%1'; use #import
import of module '%0' appears within %1
definition of module '%0' is not available; use -fmodule-file= to specify path to precompiled module interface
%select{local variable|parameter|typedef}0 %1 cannot be declared __module_private__
local %select{struct|interface|union|class|enum}0 cannot be declared __module_private__
%select{template|partial|member}0 specialization cannot be declared __module_private__
redefinition of module '%0'
import of module '%0' appears within same top-level module '%1'
%select{declaration|definition|default argument|explicit specialization|partial specialization}0 of %1 must be imported from module '%2' before it is required
%select{missing '#include'|missing '#include %3'}2; %select{||default argument of |explicit specialization of |partial specialization of }0%1 must be %select{declared|defined|defined|declared|declared}0 before it is used
%select{declaration|definition|default argument|explicit specialization|partial specialization}0 of %1 must be imported from one of the following modules before it is required:%2
multiple initializations given for base %0
virtual function %q0 has more than one final overrider in %1
multiple initializations given for non-static member %0
multiversioned function declaration has a different %select{calling convention|return type|constexpr specification|inline specification|storage class|linkage}0
attribute '%select{target|cpu_specific|cpu_dispatch}0' multiversioning cannot be combined with attribute %1
attribute '%select{target|cpu_specific|cpu_dispatch}0' multiversioned functions do not yet support %select{function templates|virtual functions|deduced return types|constructors|destructors|deleted functions|defaulted functions|constexpr functions|consteval function}1
attributes on multiversioned functions must all match, attribute %0 %select{is missing|has different arguments}1
function declaration is missing %select{'target'|'cpu_specific' or 'cpu_dispatch'}0 attribute in a multiversioned function
cannot perform a tail call to function%select{| %1}0 because it uses an incompatible calling convention
%0 attribute cannot be used from %select{a block|an Objective-C function|this context}1
%select{non-member|static member|non-static member}0 function cannot perform a tail call to %select{non-member|static member|non-static member|pointer-to-member}1 function%select{| %3}2
cannot perform a tail call to function%select{| %1}0 because its signature is incompatible with the calling function
%0 attribute requires that the return value is the result of a function call
%0 attribute requires that both caller and callee functions have a prototype
%0 attribute may not be used with variadic functions
cannot perform a tail call %select{from|to}0 a %select{constructor|destructor}1
no matching %0 function for non-allocating placement new expression; include <new>
lookup of %0 in member access expression is ambiguous
%0 cannot appear before '::' because it is not a class%select{ or namespace|, namespace, or enumeration}1; did you mean ':'?
type %0 cannot be used prior to '::' because it has no members
%select{call to non-static member function|use of non-static data member}0 %2 of %1 from nested type %3
%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 discards qualifiers in nested pointer types
nested redefinition of %0
'abi_tag' %0 missing in original declaration
allocation of %select{incomplete|sizeless}0 type %1
no %select{getter|setter}0 defined for property %1
invalid use of '__super', %0 has no base classes
no matching function %0 found in local scope; did you mean %3?
no member named %0 in %1
no member named %0 in %1; did you mean to use '->' instead of '.'?
no member named %0 in %1; did you mean %select{|simply }2%3?
no template named %0 in %1
no template named %0 in %1; did you mean %select{|simply }2%3?
cannot find interface declaration for %0
no suitable member %0 in %1
no @interface declaration found in class messaging of %0
no template named %0
no template named %0; did you mean %1?
no getter method %1 for %select{increment|decrement}0 of property
atomic constraint must be of type 'bool' (found %0)
anonymous non-C-compatible type given name for linkage purposes by %select{typedef|alias}0 declaration after its linkage was computed; add a tag name here to establish linkage prior to definition
non-consteval function %0 cannot override a consteval function
non-deleted function %0 cannot override a deleted function
non-extern declaration of %0 follows extern declaration
defaulting %select{this %sub{select_defaulted_comparison_kind}1|the corresponding implicit 'operator==' for this defaulted 'operator<=>'}0 would delete it after its first declaration
non-static declaration of %0 follows static declaration
member %0 of %1 is not a template; did you mean %select{|simply }2%3?
%0 does not name a template but is followed by template arguments
%0 does not name a template but is followed by template arguments; did you mean %1?
non-thread-local declaration of %0 follows thread-local declaration
cannot %select{use type %1 for a function/method parameter|use type %1 for function/method return|default-initialize an object of type %1|declare an automatic variable of type %1|copy-initialize an object of type %1|assign to a variable of type %1|construct an automatic compound literal of type %1|capture a variable of type %1|cannot use volatile type %1 where it causes an lvalue-to-rvalue conversion}3 since it %select{contains|is}2 a union that is non-trivial to %select{default-initialize|destruct|copy}0
non-type template argument refers to subobject '%0'
sorry, non-type template argument of type %0 is not yet supported
qualified name refers into a specialization of %select{function|variable}0 template %1
non-type template parameter %0 with type %1 has incompatible initializer of type %2
%0 is not virtual and cannot be declared pure
address argument to nontemporal builtin must be a pointer (%0 invalid)
address argument to nontemporal builtin must be a pointer to integer, float, pointer, or a vector of such types (%0 invalid)
%select{assignment to readonly property|no setter method %1 for assignment to property}0
%select{%select{increment|decrement}1 of readonly property|no setter method %2 for %select{increment|decrement}1 of property}0
cannot specialize a %select{dependent template|template template parameter}0
type %0 is not a direct or virtual base of %1
call to function %0 that is neither visible in the template definition nor found by argument-dependent lookup
anonymous bit-field has non-integral type %0
bit-field %0 has non-integral type %1
no %select{struct|interface|union|class|enum}0 named %1 in %2
%0 attribute only applies to %select{Objective-C object|pointer|pointer-to-CF-pointer}1 parameters
domain argument %select{|%1 }0does not refer to global constant
domain argument %0 does not point to an NSString or CFString constant
overriding method has mismatched ns_returns_%select{not_retained|retained}0 attributes
nullability keyword %0 cannot be applied to multi-level pointer type %1
nullability specifier %0 cannot be applied to non-pointer type %1
array of interface %0 is invalid (probably should be an array of pointers)
parameter of %0 attribute must be a single name of an Objective-C %select{class|protocol}1
attribute %0 can only be applied to @protocol definitions, not forward declarations
parameter of %0 attribute must be 'id' when used on a typedef
could not find Objective-C class %0 to convert %1 to %2
%0 must be name of an Objective-C class to be able to convert %1 to %2
%0 must be explicitly converted to %1; use %select{%objcclass2|%objcinstance2}3 method for this conversion
CF object of type %0 is bridged to %1, which is not an Objective-C class
%select{|direct }0%select{method|property}1 declaration conflicts with previous %select{|direct }2declaration of %select{method|property}1 %3
direct method was declared in %select{the primary interface|an extension|a category}0 but is implemented in %select{the primary interface|a category|a different category}1
methods that %select{override superclass methods|implement protocol requirements}0 cannot be direct
'objc_direct' attribute cannot be applied to %select{methods|properties}0 declared in an Objective-C protocol
%select{category %1|class extension}0 cannot conform to protocol %2 because of direct members declared in interface %3
cannot use '%0' with Objective-C exceptions disabled
illegal type %0 used in a boxed expression
incomplete type %0 used in a boxed expression
Objective-C index expression has incomplete class type %0
method for accessing %select{dictionary|array}1 element must have Objective-C object return type instead of %0
'__kindof' specifier cannot be applied to non-object type %0
literal construction method %0 has incompatible signature
%0 %select{parameter|return}1 type is unsupported; support for vector types for this target is introduced in %2
indexing expression is invalid because subscript type %0 has multiple type conversion functions
non-trivially copyable type %0 cannot be used in a boxed expression
ObjectiveC object of type %0 is bridged to %1, which is not valid CF object
cannot assign to class object (%0 invalid)
%select{extension|category}0 of non-parameterized class %1 cannot have type parameters
forward declaration of non-parameterized class %0 cannot have type parameters
class %0 previously declared with type parameters
objc_precise_lifetime only applies to retainable types; type here is %0
property attributes '%0' and '%1' are mutually exclusive
property with '%0' attribute must be of object type
cannot implement a category for class %0 that is only visible via the Objective-C runtime
cannot implement subclass %0 of a superclass %1 that is only visible via the Objective-C runtime
%select{dictionary|array}1 subscript base type %0 is not an Objective-C object
method object parameter type %0 is not object type
method index parameter type %0 is not integral type
method key parameter type %0 is not object type
expected method to %select{read|write}1 %select{dictionary|array}2 element not found on object of type %0
cannot assign to this %select{dictionary|array}1 because assigning method's 2nd parameter of type %0 is not an Objective-C pointer type
indexing expression is invalid because subscript type %0 is not an Objective-C pointer
indexing expression is invalid because subscript type %0 is not an integral or Objective-C pointer type
@synchronized requires an Objective-C object type (%0 invalid)
@throw requires an Objective-C object type (%0 invalid)
type argument %0 does not satisfy the bound (%1) of type parameter %2
type argument %0 cannot explicitly specify nullability
no type or protocol named %0
type argument %0 must be a pointer (requires a '*')
type argument %0 is neither an Objective-C object nor a block type
type argument %0 cannot be qualified with '%1'
angle brackets contain both a %select{type|protocol}0 (%1) and a %select{protocol|type}0 (%2)
type arguments cannot be applied to non-class type %0
type arguments cannot be applied to non-parameterized class %0
type arguments cannot be applied to already-specialized class type %0
too %select{many|few}0 type arguments for class %1 (have %2, expected %3)
%select{forward class declaration|class definition|category|extension}0 has too %select{few|many}1 type parameters (expected %2, have %3)
type bound %0 for type parameter %1 conflicts with %select{implicit|previous}2 bound %3%select{for type parameter %5|}4
type parameter %0 bound %1 cannot explicitly specify nullability
missing type bound %0 for type parameter %1 in %select{@interface|@class}2
missing '*' in type bound %0 for type parameter %1
type bound %0 for type parameter %1 is not an Objective-C pointer type
type bound %1 for type parameter %0 cannot be qualified with '%2'
redeclaration of type parameter %0
%select{in|co|contra}0variant type parameter %1 conflicts with previous %select{in|co|contra}2variant type parameter %3
field %0 with variable sized type %1 is not at the end of class
interface type %1 cannot be %select{returned|passed}0 by value; did you forget * in %1?
offsetof requires array type, %0 invalid
cannot compute offset of bit-field %0
offsetof of incomplete type %0
offsetof requires struct, union, or class type, %0 invalid
argument of aligned clause should be array%select{ or pointer|, pointer, reference to array or reference to pointer}1, not %0
ambiguous conversion from type %0 to an integral or unscoped enumeration type
directive '#pragma omp atomic%select{ %0|}1' cannot be used with '%2' clause
bit fields cannot be used to specify storage in a '%0' clause
arguments of OpenMP clause '%0' with bitwise operators cannot be of floating type
arguments of OpenMP clause '%0' for 'min' or 'max' must be of %select{scalar|arithmetic}1 type
'%0' and '%1' clause are mutually exclusive and may not appear on the same directive
const-qualified list item cannot be %0
const-qualified variable without mutable fields cannot be %0
const-qualified variable cannot be %0
redefinition of user-defined mapper for type %0 with name %1
only variable %0 is allowed in map clauses of this 'omp declare mapper' directive
redefinition of user-defined reduction for type %0
%0 must not appear in both clauses 'to' and 'link'
function with '#pragma omp declare variant' has a different %select{calling convention|return type|constexpr specification|inline specification|storage class|linkage}0
'#pragma omp declare variant' does not support %select{function templates|virtual functions|deduced return types|constructors|destructors|deleted functions|defaulted functions|constexpr functions|consteval function}0
variant in '#pragma omp declare variant' with type %0 is incompatible with type %1
the user condition in the OpenMP context selector needs to be constant; %0 is not
variable %0 must have explicitly specified data sharing attributes, data mapping attributes, or in an is_device_ptr clause
'depend' clauses cannot be mixed with '%0' clause
expected%select{| %1}0 loop iteration variable
'depend(%select{source|sink:vec}0)' clause%select{|s}0 cannot be mixed with 'depend(%select{sink:vec|source}0)' clause%select{s|}0
'device_type(%0)' does not match previously specified 'device_type(%1)' for the same declaration
'%0' region encountered before requires directive with '%1' clause
expected addressable lvalue expression, array element%select{ or array section|, array section or array shaping expression}0%select{| of non 'omp_depend_t' type}1
expected constant sized array of 'omp_alloctrait_t' elements, not %0
expected variable name as a base of the array %select{subscript|section}0
expected lvalue expression%select{ of 'omp_depend_t' type, not %1|}0
%0 is not a global variable, static local variable or static data member
%0 is not a global variable, static local variable or static data member; did you mean %1
expected variable name%select{| or data member of current class}0
expected variable name%select{|, data member of current class}0, array element or array section
expression requires explicit conversion from %0 to %1
a firstprivate variable with incomplete type %0
'flush' directive with memory order clause '%0' cannot have the list
'#pragma omp declare %select{simd|variant}0' can only be applied to functions
arguments of '#pragma omp %0' must have %select{global storage|static storage duration}1
'%0' type not found; include <omp.h>
expression has incomplete class type %0
interop variable %0 used in multiple action clauses
expected%select{| non-const}0 variable of type 'omp_interop_t'
%select{map type '%1' is not allowed|map type must be specified}0 for '#pragma omp %2'
cannot find a valid user-defined mapper for type %0 with name %1
'#pragma omp %0' directive must appear only in file scope
%0 used in declare target directive is not a variable or a function name
expected loop invariant expression or '<invariant1> * %0 + <invariant2>' kind of expression
expected integral or pointer type as the iterator-type, not %0
iterator step expression %0 evaluates to 0
iterator step expression %0 is not the integral expression
a lastprivate variable with incomplete type %0
argument of a linear clause should be of integral or pointer type, not %0
a linear variable with incomplete type %0
'%0' statement cannot be used in OpenMP for loop
increment expression must cause %0 to %select{decrease|increase}1 on each iteration of OpenMP for loop
condition of OpenMP for loop must be a relational comparison ('<', '<=', '>', %select{or '>='|'>=', or '!='}0) of loop variable %1
increment clause of OpenMP for loop must perform simple addition or subtraction on loop variable %0
loop iteration variable in the associated loop of 'omp %1' directive may not be %0, predetermined as %2
variable must be of integer or %select{pointer|random access iterator}0 type
argument to '%0' clause must be a %select{non-negative|strictly positive}1 integer value
expected at least one %0 clause for '#pragma omp %1'
variable %0 must have explicitly specified data sharing attributes
expected addressable lvalue in '%0' clause
%select{statement after '#pragma omp %1' must be a for loop|expected %2 for loops after '#pragma omp %1'%select{|, but found only %4}3}0
expression must have integral or unscoped enumeration type, not %0
unable to resolve declare reduction construct for type %0
variable can appear only once in OpenMP '%0' clause
'ordered' directive %select{without any clauses|with 'threads' clause}0 cannot be closely nested inside ordered region with specified parameter
'ordered' clause with a parameter can not be specified in '#pragma omp %0' directive
orphaned 'omp %0' directives are prohibited; perhaps you forget to enclose the directive into a %select{|||target |teams|for, simd, for simd, parallel for, or parallel for simd }1region?
%select{orphaned 'omp section' directives are prohibited, it|'omp section' directive}0 must be closely nested to a sections region%select{|, not a %1 region}0
argument of a reduction clause of a %0 construct must not appear in a firstprivate clause on a task construct
expected reference to one of the parameters of function %0%select{| or 'this'}1
parent region for 'omp %select{cancellation point|cancel}0' construct cannot be nowait
parent region for 'omp %select{cancellation point|cancel}0' construct cannot be ordered
a private variable with incomplete type %0
region cannot be%select{| closely}0 nested inside '%1' region%select{|; perhaps you forget to enclose 'omp %3' directive into a parallel region?|; perhaps you forget to enclose 'omp %3' directive into a for or a parallel for region with 'ordered' clause?|; perhaps you forget to enclose 'omp %3' directive into a target region?|; perhaps you forget to enclose 'omp %3' directive into a teams region?|; perhaps you forget to enclose 'omp %3' directive into a for, simd, for simd, parallel for, or parallel for simd region?}2
cannot nest 'critical' regions having the same name %0
OpenMP constructs may not be nested inside a simd region%select{| except for ordered simd, simd, scan, or atomic directive}0
list item of type %0 is not valid for specified reduction operation: unable to provide default initialization value
a reduction list item with incomplete type %0
argument of OpenMP clause '%0' must reference the same object in all threads
cannot generate code for reduction on %select{|array section, which requires a }0variable length array
reduction type cannot be %select{qualified with 'const', 'volatile' or 'restrict'|a function|a reference|an array}0 type
arguments of '#pragma omp %0' cannot be of reference type %1
%0 variable must be %1
Only one %0 clause can appear on a requires directive in a single translation unit
section of pointer to function type %0
section of pointer to incomplete type %0
section length is evaluated to a negative value %0
section length is unspecified and cannot be inferred because subscripted value is %select{not an array|an array of unknown bound}0
section stride is evaluated to a non-positive value %0
exactly one '%0' directive must appear in the loop body of an enclosing directive
directive '#pragma omp %0' cannot contain more than one %select{'seq_cst', 'relaxed', |}1'acq_rel', 'acquire' or 'release' clause
array shaping dimension is evaluated to a non-positive value %0
'%0' statement cannot be used in OpenMP simd region
'%0' clause with '%1' modifier cannot be specified if an 'ordered' clause is specified
single declaration is expected after 'declare %select{simd|variant}0' directive
the loop %select{initializer|condition}0 expression depends on the current loop control variable
threadprivate variables are not allowed in '%0' clause
threadprivate variable with incomplete type %0
array section %select{lower bound|length}0 is not an integer
expected %0 in OpenMP clause '%1'
modifier '%0' cannot be used along with modifier '%1'
incorrect reduction identifier, expected one of '+', '-', '*', '&', '|', '^', '&&', '||', 'min' or 'max' or declare reduction for type %0
expected%select{| one of}0 %1 directive name modifier%select{|s}0
%select{a variable|a parameter|'this'}0 cannot appear in more than one %1 clause
expected variable of the '%0' type%select{|, not %2}1
'#pragma omp %0' must appear in the scope of the %q1 variable declaration
variable %0 cannot be threadprivate because it is %select{thread-local|a global named register variable}1
'#pragma omp %0' must precede all references to variable %q1
%0 variable cannot be in a %1 clause in '#pragma omp %2' directive
arguments of OpenMP clause '%0' in '#pragma omp %2' directive cannot be of variably-modified type %1
expected an integer or a pointer type of the outer loop counter '%0' for non-rectangular nests
function with 'device_type(%0)' is not available on %select{device|host}1
%0 variable cannot be %1
directive name modifier '%0' is not allowed for '#pragma omp %1'
expected %select{'val' modifier|one of 'ref', val' or 'uval' modifiers}0
variable of non-reference type %0 can be used only with 'val' modifier, but used with '%1'
only %select{'omp_priv' or 'omp_orig'|'omp_in' or 'omp_out'}0 variables are allowed in %select{initializer|combiner}0 expression
variables in the %0 address space can only be declared in the outermost scope of a kernel function
atomic variable can be %select{assigned|initialized}0 to a variable only in global address space
illegal call to %0, expected %1 argument type
invalid number of arguments to function: %0
first argument to %0 must be a pipe type
invalid pipe access modifier (expecting %0)
invalid argument type to function %0 (expecting %1 having %2)
invalid argument %0 to function: %1, expecting a generic pointer argument
cannot cast non-zero value '%0' to 'event_t'
casting to type %0 is not allowed
vector component access has invalid length %0.  Supported: 1,2,3,4,8,16.
%select{pointers|references}0 to functions are not allowed
%select{non-kernel function|function scope}0 variable cannot be declared in %1 address space
%select{program scope|static local|extern}0 variable must reside in %1 address space
declaring variable of type %0 is not allowed
%select{loading directly from|assigning directly to}0 pointer to type %1 requires cl_khr_fp16. Use vector data %select{load|store}0 builtin functions instead
implicit declaration of function %0 is invalid in OpenCL
implicit conversions between vector types (%0 and %1) are not permitted
invalid block variable declaration - must be %select{const qualified|initialized}0
declaring function parameter of type %0 is not allowed%select{; did you forget * ?|}1
access qualifier %0 can not be used for %1 %select{|prior to OpenCL C version 2.0 or in version 3.0 and without __opencl_c_read_write_images feature}2
declaring function return value of type %0 is not allowed %select{; did you forget * ?|}1
array of %0 type is invalid in OpenCL
attribute %0 can only be applied to an OpenCL kernel function
%select{function|kernel}0 cannot be called 'main'
pointer to type %0 is invalid in OpenCL
use of %select{type|declaration}0 %1 requires %2 support
scalar operand type has greater rank than the type of the vector element. (%0 and %1)
invalid application of '%0' to a void type
type %0 can only be used as a function parameter in OpenCL
%0 type %1 not found; include the base header with -finclude-default-header
the %0 type cannot be used to declare a structure or union field
use of 'operator->' on type %0 would invoke a sequence of more than %1 'operator->' calls
%0 cannot take a dependent type as first parameter; use %1 instead
first parameter of %0 must have type %1
parameter of %0 cannot have a default argument
%0 cannot be declared inside a namespace
%0 cannot be declared static in global scope
%0 cannot have a dependent return type; use %1 instead
%0 must return type %1
%0 template must have at least two parameters
%0 must have at least one parameter
%0 cannot take a dependent type as first parameter; use size_t (%1) instead
%0 takes type size_t (%1) as first parameter
parameter of overloaded %0 cannot have a default argument
overloaded %0 must be a %select{unary|binary|unary or binary}2 operator (has %1 parameter%s1)
overloaded %0 must be a non-static member function
overloaded %0 must have at least one parameter of class or enumeration type
parameter of overloaded post-%select{increment|decrement}1 operator must have type 'int' (not %0)
overloaded %0 cannot be a static member function
overloaded %0 cannot be variadic
os_log() argument %0 is too big (%1 bytes, max %2)
defaulting this %sub{select_special_member_kind}0 would delete it after its first declaration
qualified reference to %0 is a constructor name rather than a %select{template name|type}1 in this context
__builtin_mul_overflow does not support signed _ExtInt operands of more than %0 bits
operand argument to overflow builtin must be an integer (%0 invalid)
result argument to overflow builtin must be a pointer to a non-const integer (%0 invalid)
call to %0 is ambiguous
ambiguous conversion for %select{|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2
call to constructor of %0 is ambiguous
call to member function %0 is ambiguous
call to object of type %0 is ambiguous
use of overloaded operator '%0' is ambiguous (with operand types %1 and %2)
use of overloaded operator '%0' is ambiguous (operand type %1)
call to deleted function %0
object of type %0 cannot be compared because its %1 is implicitly deleted
%select{|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2 uses deleted function
call to deleted constructor of %0
call to deleted member function %0
call to deleted function call operator in type %0
overload resolution selected deleted operator '%0'
call to implicitly-deleted %select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor|function}0 of %1
object of type %0 cannot be %select{constructed|copied|moved|assigned|assigned|destroyed}1 because its %sub{select_special_member_kind}1 is implicitly deleted
cannot convert %1 to %2 without a conversion operator
type %0 does not provide a %select{subscript|call}1 operator
no matching conversion for %select{|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2
no matching function for call to %0
no matching constructor for initialization of %0
no matching literal operator for call to %0%select{| with argument of type %2| with arguments of types %2 and %3}1%select{| or 'const char *'}4%select{|, and no matching literal operator template}5
no matching member function for call to %0
no matching function for call to object of type %0
no viable overloaded '%0'
no viable overloaded operator[] for type %0
return type %0 of selected 'operator==' function for rewritten '%1' comparison is not 'bool'
reference to %select{overloaded|multiversioned}1 function could not be resolved; did you mean to call it%select{| with no arguments}0?
'ownership_returns' attribute index does not match; here it is %0
%0 attribute only applies to %select{pointer|integer}1 arguments
pack expansion contains parameter packs %0 and %1 that have different lengths (%2 vs. %3)
pack expansion contains parameter pack %0 that has a different length (%1 vs. %2) from outer parameter packs
pack expansion contains parameter pack %0 that has a different length (at least %1 vs. %2) from outer parameter packs
pack expansion for initialization of member %0
default arguments cannot be added to an out-of-line definition of a member of a %select{class template|class template partial specialization|nested class in a template}0
missing default argument on parameter %0
default argument references local variable %0 of enclosing function
default argument references parameter %0
%select{parameters|function return value}0 cannot have __fp16 type; did you forget * ?
%select{class|variable}0 template partial specialization does not specialize any template argument; to %select{declare|define}1 the primary template, remove the template argument list
partial specialization of %0 does not use any of its template parameters
ambiguous partial specializations of %0
class template partial specialization %0 cannot be redeclared
deduced type %0 does not satisfy %1
call to pointer to member function of type %0 drops '%1' qualifier%s2
pointer-to-member function type %0 can only be called on an %select{rvalue|lvalue}1
invalid use of pointer to member type after %select{.*|->*}0
this builtin is only valid on POWER%0 or later CPUs
attribute %0 can't be applied to %1
negated attribute subject matcher sub-rule '%0' contradicts sub-rule '%1'
redundant attribute subject matcher sub-rule '%0'; '%1' already matches those declarations
'#pragma clang attribute %select{%1.|}0pop' with no matching '#pragma clang attribute %select{%1.|}0push'
%select{incompatible|duplicate}0 directives '%1' and '%2'
invalid argument of type %0; expected an integer type
%select{invalid value '%0'; must be positive|value '%0' is too large}1
expected a for, while, or do-while loop to follow '%0'
argument to #pragma section is not valid for this target: %0
__builtin_preserve_enum_value argument %0 invalid
__builtin_preserve_enum_value argument %0 not a constant
__builtin_preserve_field_info argument %0 not a constant
__builtin_preserve_field_info argument %0 not a field access
__builtin_preserve_type_info argument %0 invalid
__builtin_preserve_type_info argument %0 not a constant
instance variable %0 is private
type of property %0 (%1) does not match type of accessor %2 (%3)
property %0 found on object of type %1; did you mean to access it with the "." operator?
property %0 is already implemented
property %0 has a variably modified type
type of property %0 (%1) does not match type of instance variable %2 (%3)
property access is using %0 method which is unavailable
property %0 refers to an incomplete Objective-C class %1 (with no @interface available)
property %0 not found on object of type %1
property %0 cannot be found in forward class object %1
property %0 not found on object of type %1; did you mean %2?
synthesized properties %0 and %1 both claim setter %2 - use of this setter will cause unexpected behavior
property cannot have array or function type %0
instance variable %0 is protected
property %select{of type %1|with attribute '%1'|without attribute '%1'|with getter %1|with setter %1}0 was selected for synthesis
object expression of non-scalar type %0 cannot be used in a pseudo-destructor expression
%0 does not refer to a type name in pseudo-destructor expression; expected the name of type %1
the type of object expression %diff{($) does not match the type being destroyed ($)|does not match the type being destroyed}0,1 in pseudo-destructor expression
friend function definition cannot be qualified with '%0'
friend declaration of %0 does not match any declaration in %1
type operand %0 of 'typeid' cannot have '%1' qualifier
qualified member access refers to a member in %0
%q0 is not a member of class %1
%select{property|instance variable}0 access cannot be qualified with '%1'
cannot build range expression with array function parameter %0 since parameter with array type %1 is treated as pointer type %2
invalid type %0 to %1 operator
%select{struct|union}0 kernel parameters may not contain pointers
trying to recursively use %0 as superclass of %1
redeclaration of %0 with a different type%diff{: $ vs $|}1,2
redefinition of %0
redefinition of %0 as different kind of symbol
redefinition of %0 as an alias for a different namespace
redefinition of %0 with a different type%diff{: $ vs $|}1,2
%select{typedef|type alias|type alias template}0 redefinition with different types%diff{ ($ vs $)|}1,2
redefinition of a 'extern inline' function %0 is not supported in %select{C99 mode|C++}1
redefinition of enumerator %0
redefinition of label %0
redefinition of %select{typedef|type alias}0 for variably-modified type %1
reference to %select{__device__|__global__|__host__|__host__ __device__}0 %select{function|variable}1 %2 in %select{__device__|__global__|__host__|__host__ __device__}3 function
reference to %select{__device__|__global__|__host__|__host__ __device__}0 function %1 in global initializer
reference initialization of type %0 with initializer of type %1 is ambiguous
%0 does not refer to a value
ref-qualifier '%select{&&|&}0' is not allowed on a constructor
ref-qualifier '%select{&&|&}0' is not allowed on a destructor
cannot overload a member function %select{without a ref-qualifier|with ref-qualifier '&'|with ref-qualifier '&&'}0 with a member function %select{without a ref-qualifier|with ref-qualifier '&'|with ref-qualifier '&&'}1
binding reference %diff{of type $ to value of type $|to value}0,1 %select{drops %3 qualifier%plural{1:|2:|4:|:s}4|changes address space|not permitted due to incompatible qualifiers}2
reference %diff{to %select{type|incomplete type}1 $ could not bind to an %select{rvalue|lvalue}2 of type $|could not bind to %select{rvalue|lvalue}2 of incompatible type}0,3
reference to type %0 cannot bind to an initializer list
reference of type %0 cannot bind to a temporary object because of address space mismatch
%select{non-const|volatile}0 reference cannot bind to bit-field%select{| %1}2
%select{non-const|volatile}0 reference cannot bind to matrix element
%select{non-const|volatile}0 reference cannot bind to vector element
invalid reference to function %0: constraints not satisfied
reference to local %select{variable|binding}1 %0 declared in enclosing %select{%3|block literal|lambda expression|context}2
declaration of reference variable %0 requires an initializer
reference to type %0 requires an initializer
function declared with regparm(%0) attribute was previously declared %plural{0:without the regparm|:with the regparm(%1)}1 attribute
%0 attribute cannot be repeated
constraint variable %0 cannot be used in an evaluated context
cannot return from %0
%select{void function|void method|constructor|destructor}1 %0 must not return a value
builtin requires '%0' extension support to be enabled
%0 cannot use 'super' because it is a root class
rvalue reference type %0 is not allowed in exception specification
sampler_t variable required - got %0
sampler_t initialization requires 32-bit integer, not %0
second argument to 'va_arg' is of abstract type %0
second argument to 'va_arg' is of incomplete type %0
%0 causes a section type conflict with %1
selector element of type %0 cannot be a constant lvalue expression
selector element type %0 is not a valid object
requested shift is a vector of type %0 but the first operand is not a vector (%1)
%select{|reference to }0sizeless type %1 is not allowed in exception specification
non-local variable with sizeless type %0
invalid application of '%0' to a function type
invalid application of '%0' to %select{an incomplete|sizeless}1 type %2
invalid application of '%select{sizeof|alignof|typeof}0' to bit-field
application of '%select{alignof|sizeof}1' to interface %0 is not supported on this architecture and platform
%0 does not refer to the name of a parameter pack
%0 does not refer to the name of a parameter pack; did you mean %1?
argument to 'operator<=>' %select{cannot be narrowed from type %1 to %2|evaluates to %1, which cannot be narrowed to type %2}0
specialization of member %q0 does not specialize an instantiated member
explicit specialization of %0 after instantiation
cannot reference member of primary template because deduced class template specialization %0 is %select{instantiated from a partial|an explicit}1 specialization
cannot specialize %select{|(with 'template<>') }0a member of an unspecialized template
forward declaration of %select{class|struct|interface|union|enum}0 cannot have a nested name specifier
static_assert failed%select{ %1|}0
static_assert failed due to requirement '%0'%select{ %2|}1
static data member %0 not allowed in anonymous %sub{select_tag_type_kind}1
static data member %0 not allowed in local %sub{select_tag_type_kind}2 %1
static data member %0 already has an initializer
cannot cast %0 to %1 via virtual base %2
static declaration of %0 follows non-static declaration
static member %0 cannot be a bit-field
'static' member function %0 overrides a virtual function in a base class
standard library implementation of %0 is not supported; %select{member '%2' does not have expected form|member '%2' is missing|the type is not trivially copyable|the type does not have the expected form}1
unsupported standard library implementation: 'std::%0' is not a class template
%0 attribute cannot be applied to a declaration
@catch parameter cannot have storage specifier '%0'
existing instance variable %1 for strong property %0 may not be __weak
subscript of pointer to function type %0
subscript of pointer to %select{incomplete|sizeless}0 type %1
subscript requires size of interface %0, which is not constant for this architecture and platform
'%0' parameter must have pointer%select{| to unqualified pointer}1 type; type here is %2
'swift_async' completion handler parameter must have block type returning 'void', type here is %0
%0 attribute with 'nonnull_error' convention can only be applied to a %select{function|method}1 with a completion handler with an error parameter
%0 attribute with '%1' convention must have an integral-typed parameter in completion handler at index %2, type here is %3
%0 attribute must be applied to a %select{function|method}1 annotated with non-'none' attribute 'swift_async'
'%0' parameter can only be used with swiftcall%select{ or swiftasynccall|}1 calling convention%select{|s}1
switch condition type %0 requires explicit conversion to %1
switch condition has incomplete class type %0
multiple conversions from switch condition type %0 to an integral or enumeration type
@synthesize not allowed on a class property %0
synthesized property with variable size type %0 requires an existing instance variable
definition of type %0 conflicts with %select{typedef|type alias}1 of the same name
%select{type tag|argument}0 index %1 is greater than the number of arguments specified
implicit declaration introduced by elaborated type conflicts with a %select{non-struct type|non-class type|non-union type|non-enum type|typedef|type alias|template|type alias template|template template argument}0 of the same name
%select{non-struct type|non-class type|non-union type|non-enum type|typedef|type alias|template|type alias template|template template argument}1 %0 cannot be referenced with a %select{struct|interface|union|class|enum}2 specifier
attributes '%0("%2")' and '%1("%2")' are mutually exclusive
ambiguous constructor call when %sub{select_initialized_entity_kind}0 of type %1
%sub{select_initialized_entity_kind}0 of type %1 invokes deleted constructor
copying a temporary object of incomplete type %0
no viable constructor %sub{select_initialized_entity_kind}0 of type %1
address taken in non-type template argument for template parameter of reference type %0
deduced incomplete pack %0 for template parameter %1
non-type template argument refers to non-static data member %0
constraints not satisfied for %select{class template|function template|variable template|alias template|template template parameter|template}0 %1%2
%select{too few|too many}0 template arguments for %select{class template|function template|variable template|alias template|template template parameter|concept|template}1 %2
sorry, non-type template argument of pointer-to-member type %1 that refers to member %q0 of a different class is not supported yet
non-type template argument refers to non-static member function %0
template argument for template template parameter must be a class template%select{| or type alias template}0
non-type template parameter of reference type %diff{$ cannot bind to template argument of type $|cannot bind to template of incompatible argument type}0,1
template argument for non-type template parameter is treated as function type %0
non-type template argument of type %0 is not a constant expression
non-type template argument for template parameter of pointer type %0 must have its address taken
non-type template argument of type %0 cannot be converted to a value of type %1
non-type template argument of type %0 is not an integral constant expression
non-type template argument of type %0 must have an integral or enumeration type
non-type template argument refers to %select{function|object}0 %1 that does not have linkage
reference binding of non-type template parameter %diff{of type $ to template argument of type $|to template argument}0,1 ignores qualifiers
non-type template argument of reference type %0 is not an object
null non-type template argument must be cast to template parameter type %0
null non-type template argument of type %0 does not match template parameter of type %1
pack expansion used as argument for non-pack parameter of %select{alias template|concept}0
template name refers to non-type template %0
%select{implicit|explicit}0 instantiation of undefined template %1
%select{implicit|explicit}0 instantiation of template %1 within its own definition
missing 'template' keyword prior to dependent template name '%0%1'
'%0%1' instantiated to a class template, not a function template
%0%select{| following the 'template' keyword}1 cannot refer to a dependent template
%0%select{| following the 'template' keyword}1 does not refer to a template
member %0 declared as a template
extraneous 'template<>' in declaration of member %0
use of %select{class template|function template|variable template|alias template|template template parameter|concept|template}0 %1 requires template arguments
a non-type template parameter cannot have type %0 before C++20
a non-type template parameter cannot have type %0
template non-type parameter has a different type %0 in template %select{|template parameter }1redeclaration
non-type template parameter has incomplete type %0
non-type template parameter has non-literal type %0
type %0 of non-type template parameter is not a structural type
non-type template parameter has rvalue reference type %0
template parameter has a different kind in template %select{|template parameter }0redeclaration
%select{too few|too many}0 template parameters in template %select{|template parameter }1redeclaration
template parameter list matching the non-templated nested type %0 should be empty ('template<>')
declaration of %0 shadows template parameter
%select{template type|non-type template|template template}0 parameter%select{| pack}1 conflicts with previous %select{template type|non-type template|template template}0 parameter%select{ pack|}1
nested name specifier '%0' for declaration does not refer into a class, class template or class template partial specialization
recursive template instantiation exceeded maximum depth of %0
explicit specialization of %0 in function scope
default argument not permitted on an explicit %select{instantiation|specialization}0 of function %1
template specialization or definition requires a template parameter list corresponding to the nested type %0
%select{class template|class template partial|variable template|variable template partial|function template|member function|static data member|member class|member enumeration}0 specialization of %1 must occur at global scope
%select{class template|class template partial|variable template|variable template partial|function template|member function|static data member|member class|member enumeration}0 specialization of %1 not in %select{a namespace enclosing %2|class %2 or an enclosing namespace}3
can only provide an explicit specialization for a class template, function template, variable template, or a member function, static data member, %select{or member class|member class, or member enumeration}0 of a class template
extraneous 'template<>' in declaration of %0 %1
template template argument %0 is more constrained than template template parameter %1
extraneous 'template<>' in declaration of variable %0
tentative definition has type %0 that is never completed
'this' cannot be %select{implicitly |}0captured in this context
'this' cannot be%select{| implicitly}0 used in a static member function declaration
'%0' variables must have global storage
thread-local declaration of %0 follows non-thread-local declaration
thread-local declaration of %0 with %select{static|dynamic}1 initialization follows declaration with %select{dynamic|static}1 initialization
cannot throw an object of abstract type %0
cannot throw object of incomplete type %0
cannot throw pointer to object of incomplete type %0
cannot throw object of sizeless type %0
alignment (%0) of thread-local variable %1 is greater than the maximum supported alignment (%2) for a thread-local variable on this target
function with trailing return type must specify return type 'auto', not %0
%0 requires more than 1 template argument; provide the remaining arguments explicitly to use it here
%0 cannot be defined in a type alias template
%0 cannot be defined in a condition
%0 cannot be defined in an enumeration
%0 cannot be defined in a parameter type
%0 cannot be defined in the result type of a function
%0 cannot be defined in a type specifier
type of property %0 in class extension does not match property type in primary class
'type_tag_for_datatype' attribute requires the initializer to be an %select{integer|integral}0 constant expression
'type_tag_for_datatype' attribute requires the initializer to be an %select{integer|integral}0 constant expression that can be represented by a 64 bit integer
%0 is not supported on this target
address of %select{bit-field|vector element|property expression|register variable|matrix element}0 requested
taking the address of a temporary object of type %0
conversion %diff{from $ to $|between types}0,1 is ambiguous
arithmetic on a pointer to %select{an incomplete|sizeless}0 type %1
array type %0 is not assignable
%select{cannot assign to return value because function %1 returns a const value|cannot assign to variable %1 with const-qualified type %2|cannot assign to %select{non-|}1static data member %2 with const-qualified type %3|cannot assign to non-static data member within const member function %1|cannot assign to %select{variable %2|non-static data member %2|lvalue}1 with %select{|nested }3const-qualified data member %4|read-only variable is not assignable}0
value of type %0 is not contextually convertible to 'bool'
arguments are of different types%diff{ ($ vs $)|}0,1
ordered compare requires two args of floating point type%diff{ ($ and $)|}0,1
floating point classification requires argument of floating point type (passed in %0)
called object type %0 is not a function or function pointer
argument type %0 is not a real floating point type
too few %select{|||execution configuration }0arguments to %select{function|block|method|kernel function}0 call, expected %1, have %2
too few %select{|||execution configuration }0arguments to %select{function|block|method|kernel function}0 call, expected at least %1, have %2
too few %select{|||execution configuration }0arguments to %select{function|block|method|kernel function}0 call, at least argument %1 must be specified
too few %select{|||execution configuration }0arguments to %select{function|block|method|kernel function}0 call, expected at least %1, have %2; did you mean %3?
too few %select{|||execution configuration }0arguments to %select{function|block|method|kernel function}0 call, single argument %1 was not specified
too few %select{|||execution configuration }0arguments to %select{function|block|method|kernel function}0 call, expected %1, have %2; did you mean %3?
too many %select{|||execution configuration }0arguments to %select{function|block|method|kernel function}0 call, expected %1, have %2
too many %select{|||execution configuration }0arguments to %select{function|block|method|kernel function}0 call, expected at most %1, have %2
too many %select{|||execution configuration }0arguments to %select{function|block|method|kernel function}0 call, expected at most single argument %1, have %2 arguments
too many %select{|||execution configuration }0arguments to %select{function|block|method|kernel function}0 call, expected at most %1, have %2; did you mean %3?
too many %select{|||execution configuration }0arguments to %select{function|block|method|kernel function}0 call, expected single argument %1, have %2 arguments
too many %select{|||execution configuration }0arguments to %select{function|block|method|kernel function}0 call, expected %1, have %2; did you mean %3?
cast to incomplete type %0
cast to union type from type %0 not present in union
comparison of distinct block types%diff{ ($ and $)|}0,1
comparison of distinct pointer types%diff{ ($ and $)|}0,1
equality comparison between function pointer and void pointer (%0 and %1)
comparison between pointer and integer (%0 and %1)
used type %0 where integer or floating point type is required
used type %0 where floating point type is not allowed
used type %0 where arithmetic or pointer type is required
incompatible operand types%diff{ ($ and $)|}0,1
non-pointer operand type %0 incompatible with %select{NULL|nullptr}1
%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 discards qualifiers
%select{%diff{assigning to $ from incompatible type $|assigning to type from incompatible type}0,1|%diff{passing $ to parameter of incompatible type $|passing type to parameter of incompatible type}0,1|%diff{returning $ from a function with incompatible result type $|returning type from a function with incompatible result type}0,1|%diff{converting $ to incompatible type $|converting type to incompatible type}0,1|%diff{initializing $ with an expression of incompatible type $|initializing type with an expression of incompatible type}0,1|%diff{sending $ to parameter of incompatible type $|sending type to parameter of incompatible type}0,1|%diff{casting $ to incompatible type $|casting type to incompatible type}0,1}2%select{|; dereference with *|; take the address with &|; remove *|; remove &}3%select{|: different classes%diff{ ($ vs $)|}5,6|: different number of parameters (%5 vs %6)|: type mismatch at %ordinal5 parameter%diff{ ($ vs $)|}6,7|: different return type%diff{ ($ vs $)|}5,6|: different qualifiers (%5 vs %6)|: different exception specifications}4
incompatible block pointer types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2
incompatible function pointer types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &|; remove *|; remove &}3
incompatible pointer types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &|; remove *|; remove &}3
%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 converts between pointers to integer types %select{with different sign|where one is of the unique plain 'char' type and the other is not}3
incompatible integer to pointer conversion %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &|; remove *|; remove &}3
incompatible pointer to integer conversion %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &|; remove *|; remove &}3
%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 converts between void pointer and function pointer
value of type %0 is not implicitly convertible to %1
conversion from %0 to %1 is not allowed in a converted constant expression
conversion from %0 to %1 in converted constant expression would bind reference to a temporary
variable has incomplete type %0
conversion function %diff{from $ to $|between types}0,1 invokes a deleted function
invalid operand of type %0 where floating, complex or a vector of such types is required
used type %0 where integer is required
operand of type %0 where arithmetic or pointer type is required
cannot %select{decrement|increment}1 value of type %0
%select{%diff{assigning $ to $|assigning to different types}1,0|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 changes address space of pointer
%select{%diff{assigning $ to $|assigning to different types}1,0|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 changes address space of nested pointer
%select{%diff{assigning $ to $|assigning to different types}1,0|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 changes retain/release properties of pointer
incomplete definition of type %0
incomplete type %0 is not assignable
indirection requires pointer operand (%0 invalid)
cannot take the address of an rvalue of type %0
invalid operands to binary expression (%0 and %1)
pointer to function type %0 may not be 'restrict' qualified
restrict requires a pointer or reference (%0 is invalid)
logical expression with vector %select{type %1 and non-vector type %2|types %1 and %2}0 is only supported in C++
member reference type %0 is not a pointer
%0 does not have a member named %1
%0 does not have a member named %1; did you mean %2?
member reference base type %0 is not a structure or union
member reference type %0 is %select{a|not a}1 pointer; did you mean to use '%select{->|.}1'?
cannot refer to type member %0 in %1 with '%select{.|->}2'
cannot refer to member %0 in %1 with '%select{.|->}2'
%diff{return type $ must match previous return type $|return type must match previous return type}0,1 when %select{block literal|lambda expression}2 has unspecified explicit return type
non-object type %0 is not assignable
no viable conversion%select{%diff{ from $ to $|}1,2|%diff{ from returned value of type $ to function return type $|}1,2}0
no viable conversion%diff{ from $ to incomplete type $|}0,1
%select{comparison between %diff{ ($ and $)|}0,1|arithmetic operation with operands of type %diff{ ($ and $)|}0,1|conditional operator with the second and third operands of type %diff{ ($ and $)|}0,1}2 which are pointers to non-overlapping address spaces
ordered comparison of function pointers (%0 and %1)
ordered comparison between pointer and zero (%0 and %1)
arithmetic on%select{ a|}0 pointer%select{|s}0 to%select{ the|}2 function type%select{|s}2 %1%select{| and %3}2
arithmetic on%select{ a|}0 pointer%select{|s}0 to void
statement requires expression of integer type (%0 invalid)
statement requires expression of scalar type (%0 invalid)
%diff{$ and $ are not pointers to compatible types|pointers to incompatible types}0,1
cannot combine fixed-length and sizeless SVE vectors in expression, result is ambiguous (%0 and %1)
cannot combine GNU and SVE vectors in expression, result is ambiguous (%0 and %1)
invalid argument type %0 to unary expression
vector operands do not have the same number of elements (%0 and %1)
cannot convert between vector values of different size (%0 and %1)
cannot convert between %select{scalar|vector}0 type %1 and vector type %2 as implicit conversion would cause truncation
cannot convert between vector and non-scalar values (%0 and %1)
unsupported: anonymous type given name for linkage purposes by %select{typedef|alias}0 declaration after its linkage was computed; add a tag name here to establish linkage prior to definition
typedef member %0 cannot be a bit-field
missing 'typename' prior to dependent type name '%0%1'
missing 'typename' prior to dependent type template name '%0%1'
no type named %0 in %1
no type named 'type' in %0; 'enable_if' cannot be used to disable this declaration
failed requirement '%0'; 'enable_if' cannot be used to disable this declaration
typename specifier refers to non-type member %0 in %1
typename specifier refers to non-type %0
typename specifier refers to a dependent using declaration for a value %0 in %1
%0 is unavailable
%0 is unavailable in ARC
%0 is unavailable: %1
%0 has unknown return type; cast the call to its declared return type
no known method %select{%objcinstance1|%objcclass1}0; cast the message send to the method's return type
%0 has unknown type; cast it to its declared type to use it
declaration of %0 is missing in %1 class
undeclared identifier %0 in destructor name
use of undeclared label %0
definition of class %0 must be available to use Objective-C %select{array literals|dictionary literals|numeric literals|boxed expressions|string literals}1
cannot find protocol declaration for %0
cannot find protocol declaration for %0; did you mean %1?
use of undeclared %0
use of undeclared %0; did you mean %1?
 %0 
 %0 ; did you mean %1?
cannot find interface declaration for %0
cannot find interface declaration for %0; did you mean %1?
cannot find interface declaration for %0, superclass of %1
cannot find interface declaration for %0, superclass of %1; did you mean %2?
inline variable %q0 is not defined
%select{function|variable}0 %q1 is used but not defined in this translation unit, and cannot be defined in any other translation unit because its type does not have linkage
cannot determine underlying type of incomplete enumeration type %0
%select{expression|base type|declaration type|data member type|bit-field size|static assertion|fixed underlying type|enumerator value|using declaration|friend declaration|qualifier|initializer|default argument|non-type template parameter type|exception type|partial specialization|__if_exists name|__if_not_exists name|lambda|block|type constraint|requirement|requires clause}0 contains%plural{0: an|:}1 unexpanded parameter pack%plural{0:|1: %2|2:s %2 and %3|:s %2, %3, ...}1
unexpected interface name %0: expected expression
unexpected namespace name %0: expected expression
unexpected type name %0: expected expression
cannot define the implicit copy assignment operator for %0, because non-static %select{reference|const}1 member %2 cannot use copy assignment operator
%select{constructor for %1|implicit default constructor for %1|cannot use constructor inherited from %1:}0 must explicitly initialize the %select{reference|const}2 member %3
union member %0 has reference type %1
function %0 with unknown type must be given a function type
variable %0 with unknown type cannot be given a function type
no type named %0 in %1; did you mean %select{|simply }2%3?
unknown receiver %0; did you mean %1?
unknown %select{type|class}1 name %0; did you mean %2?
unknown type name %0
unknown type name %0; did you mean %1?
%0 has unknown type, which is not supported for this kind of declaration
cannot cast %0 to its %select{private|protected}2 base class %1
illegal redeclaration of property in class extension %0 (attribute must be 'readwrite', while its primary must be 'readonly')
illegal redeclaration of 'readwrite' property in class extension %0 (perhaps you intended this to be a 'readwrite' redeclaration of a 'readonly' public property?)
use of default argument to function %0 that is declared later in class %1
use of %0 with tag type that does not match previous declaration
%0 is not a direct base of %1, cannot inherit constructors
using declaration refers into '%0', which is not a base class of %1
using declaration in class refers into '%0', which is not a class
no namespace named %0 in %1; did you mean %select{|simply }2%3?
no namespace named %0; did you mean %1?
%select{|member}0 using declaration %1 instantiates to an empty pack
'va_start' used in %select{System V|Win64}0 ABI function
variable template partial specialization %0 cannot be redefined
no variable template matches%select{| partial}0 specialization
no variable template matches specialization; did you mean to use %0 as function template instead?
%select{variable|static data member}0 instantiated with function type %1
'new' cannot allocate object of variably modified type %0
non-type template parameter of variably modified type %0
variably modified type %0 cannot be used as a template argument
'typeid' of variably modified type %0
first two arguments to %0 must have the same type
first two arguments to %0 must be vectors
'vec_step' requires built-in scalar or vector type, %0 invalid
%select{too many|too few}0 elements in vector initialization (expected %1 elements, have %2)
argument %0 to %1 must be a 2-bit unsigned literal (i.e. 0, 1, 2 or 3)
existing instance variable %1 for __weak property %0 must be __weak
%0 calling convention is not supported %select{for this target|on variadic function|on constructor/destructor|on builtin function}1
duplicate use of asm operand name "%0"
anonymous types declared in an anonymous %select{struct|union}0 are an extension
types declared in an anonymous %select{struct|union}0 are a Microsoft extension
anonymous %select{struct|union}0 cannot be '%1'
initialization of an array %diff{of type $ from a compound literal of type $|from a compound literal}0,1 is a GNU extension
implicit conversion from array size expression of type %0 to %select{integral|enumeration}1 type %2 is a C++11 extension
ISO C++ standards before C++17 do not allow new expression for type %0 to use list-initialization
ISO C++ does not allow %select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast|}0 from %1 to %2 because it casts away qualifiers, even though the source and destination types are unrelated
%select{qualifier in |static |}0array size %select{||'[*] '}0is a C99 feature
'trivial_abi' cannot be applied to %0
%select{case value|enumerator value|non-type template argument|array size|explicit specifier argument}0 %select{cannot be narrowed from type %2 to %3|evaluates to %2, which cannot be narrowed to type %3}1
use of this statement in a constexpr %select{function|constructor}0 is a C++14 extension
use of this statement in a constexpr %select{function|constructor}0 is a C++20 extension
%select{constexpr|consteval}1 %select{function|constructor}0 never produces a constant expression
function try block in constexpr %select{function|constructor}0 is a C++20 extension
variable declaration in a constexpr %select{function|constructor}0 is a C++14 extension
uninitialized variable in a constexpr %select{function|constructor}0 is a C++20 extension
type definition in a constexpr %select{function|constructor}0 is a C++14 extension
'constinit' specifier missing on initializing declaration of %0
use of the %0 attribute is a C++14 extension
use of the %0 attribute is a C++17 extension
use of the %0 attribute is a C++20 extension
decomposition declaration declared %plural{1:'%1'|:with '%1' specifiers}0 is a C++20 extension
default initialization of an object of const type %0%select{| without a user-provided default constructor}1 is a Microsoft extension
cannot delete expression with pointer-to-'void' type %0
ISO C++11 does not allow conversion from string literal to %0
ISO C++ requires field designators to be specified in declaration order; field %1 will be initialized after field %0
destructor cannot be declared using a %select{typedef|type alias}1 %0 of the class name
empty %select{struct|union}0 is a GNU extension
befriending enumeration type %0 is a C++11 extension
ISO C restricts enumerator values to range of 'int' (%0 is too %select{small|large}1)
incremented enumerator value %0 is not representable in the largest integer type
enumerator value is not representable in the underlying type %0
ambiguous use of internal linkage declaration %0 defined in multiple modules
excess elements in %select{array|vector|scalar|union|struct}0 initializer
excess elements in initializer for indivisible sizeless type %0
duplicate explicit instantiation of %0 ignored as a Microsoft extension
qualifier in explicit instantiation of %q0 requires a template-id (a typedef is not permitted)
ISO C++20 does not permit %select{an empty|a static_assert}0 declaration to appear in an export block
expression is not an %select{integer|integral}0 constant expression; folding it to a constant is a GNU extension
flexible array member %0 in otherwise empty %select{struct|interface|union|class|enum}1 is a GNU extension
flexible array member %0 in otherwise empty %select{struct|interface|union|class|enum}1 is a Microsoft extension
%0 may not be used as an array element due to flexible array member
%0 may not be nested in a struct due to flexible array member
flexible array member %0 in a union is a GNU extension
flexible array member %0 in a union is a Microsoft extension
'begin' and 'end' returning different types (%0 and %1) is a C++17 extension
redeclaration of already-defined enum %0 is a GNU extension
use of member %0 found via unqualified lookup into dependent bases of class templates is a Microsoft extension
use of member %0 before its declaration is a Microsoft extension
arithmetic on%select{ a|}0 pointer%select{|s}0 to%select{ the|}2 function type%select{|s}2 %1%select{| and %3}2 is a GNU extension
arithmetic on%select{ a|}0 pointer%select{|s}0 to void is a GNU extension
function previously declared with an %select{explicit|implicit}0 exception specification redeclared with an %select{implicit|explicit}0 exception specification
implicit declaration of function %0 is invalid in C99
implicitly declaring library function '%0' with type %1
in-class initializer for static data member of type %0 is a GNU extension
in-class initializer for static data member of type %0 requires 'constexpr' specifier
%select{|pointer to |reference to }0incomplete type %1 is not allowed in exception specification
constant expression evaluates to %0 which cannot be narrowed to type %1
type %0 cannot be narrowed to %1 in initializer list
non-constant-expression cannot be narrowed from type %0 to %1 in initializer list
initializer %select{partially |}0overrides prior initialization of this subobject
ISO C does not support '~' for complex conjugation of %0
ISO C does not support '++'/'--' on complex integer type %0
static %select{function|variable}0 %1 is used in an inline function with external linkage
static %select{function|variable}0 %1 is used in an inline function with external linkage
too many braces around %select{scalar |}0initializer
%0 is missing exception specification '%1'
import of C++ module '%0' appears within extern "C" language linkage specification
redundant #include of module '%0' appears within %1
accessing inaccessible direct base %0 of %1 is a Microsoft extension
anonymous %select{structs|unions}0 are a Microsoft extension
using the undeclared type %0 as a default template argument is a Microsoft extension
%0 is missing exception specification '%1'
%select{class template|class template partial|variable template|variable template partial|function template|member function|static data member|member class|member enumeration}0 specialization of %1 not in %select{a namespace enclosing %2|class %2 or an enclosing namespace}3 is a Microsoft extension
using declaration referring to inaccessible member '%0' (which refers to accessible member '%1') is a Microsoft compatibility extension
lookup of %0 in member access expression is ambiguous; using member of %1
%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 discards qualifiers in nested pointer types
%select{struct|union}0 without named members is a GNU extension
anonymous non-C-compatible type given name for linkage purposes by %select{typedef|alias}0 declaration; add a tag name here
non-class friend type %0 is a C++11 extension
offset of on non-POD type %0
offset of on non-standard-layout type %0
vector component name '%0' is an OpenCL C version 3.0 feature
replacement function %0 cannot be declared 'inline'
ISO C++ specifies that qualified reference to %0 is a constructor name rather than a %select{template name|type}1 in this context, despite preceding %select{'typename'|'template'}2 keyword
ISO C++20 considers use of overloaded operator '%0' (with operand types %1 and %2) to be ambiguous despite there being a unique best viable function%select{ with non-reversed arguments|}3
ISO C++20 requires return type of selected 'operator==' function for rewritten '%1' comparison to be 'bool', not %0
parameter %0 was not declared, defaulting to type 'int'
%diff{promoted type $ of K&R function parameter is not compatible with the parameter type $|promoted type of K&R function parameter is not compatible with parameter type}0,1 declared in a previous prototype
%select{class|variable}0 template partial specialization is not more specialized than the primary template
%select{class|variable}0 template partial specialization contains %select{a template parameter|template parameters}1 that cannot be deduced; this partial specialization will never be used
redefinition of typedef %0 is a C11 feature
friend function %0 retaining previous language linkage is an extension
%select{void function|void method|constructor|destructor}1 %0 should not return a value
void %select{function|method|block}1 %0 should not return void expression
non-void %select{function|method}1 %0 should return a value
C++98 requires an accessible copy constructor for class %2 when binding a reference to a temporary; was %select{private|protected}0
no viable constructor %sub{select_initialized_entity_kind}0 of type %1; C++98 requires a copy constructor when binding a reference to a temporary
invalid application of '%0' to a function type
invalid application of '%0' to a void type
'%0' is not permitted on a declaration of a type
static data member %0 in union is a C++11 extension
redeclaring non-static %0 as static is a Microsoft extension
template argument uses local type %0
non-type template argument referring to %select{function|object}0 %1 with internal linkage is a C++11 extension
declaration of %0 shadows template parameter
taking the address of a temporary object of type %0
method parameter type %diff{$ does not match super class method parameter type $|does not match super class method parameter type}0,1
C99 forbids casting nonscalar type %0 to the same type
pointer comparisons before C11 need to be between two complete or two incomplete types; %0 is %select{|in}2complete and %1 is %select{|in}3complete
comparison of distinct pointer types%diff{ ($ and $)|}0,1
equality comparison between function pointer and void pointer (%0 and %1)
comparison between pointer and integer (%0 and %1)
incompatible operand types (%0 and %1)
pointer type mismatch%diff{ ($ and $)|}0,1
pointer/integer type mismatch in conditional expression%diff{ ($ and $)|}0,1
%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 discards qualifiers
incompatible function pointer types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &|; remove *|; remove &}3
incompatible pointer types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &|; remove *|; remove &}3
%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 converts between pointers to integer types %select{with different sign|where one is of the unique plain 'char' type and the other is not}3
incompatible integer to pointer conversion %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &|; remove *|; remove &}3
incompatible pointer to integer conversion %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &|; remove *|; remove &}3
%select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 converts between void pointer and function pointer
tentative definition of variable with internal linkage has incomplete non-array type %0
ISO C++ does not allow indirection on operand of type %0
ordered comparison of function pointers (%0 and %1)
ordered comparison between pointer and zero (%0 and %1) is an extension
ordered comparison between pointer and integer (%0 and %1)
missing 'typename' prior to dependent type name '%0%1'
 %0 ; unqualified lookup into dependent bases of class template %1 is a Microsoft extension
ISO C++ requires a definition in this translation unit for %select{function|variable}0 %q1 because its type does not have linkage
unelaborated friend declaration is a C++11 extension; specify '%select{struct|interface|union|class|enum}0' to befriend %1
union member %0 has reference type %1, which is a Microsoft extension
use of out-of-scope declaration of %0%select{| whose type is not compatible with that of an implicit declaration}1
field %0 with variable sized type %1 not at the end of a struct or class is a GNU extension
'%0' cannot be signed or unsigned
constrained by %select{|implicitly }1%select{private|protected}0 inheritance here
%select{|implicitly }1declared %select{private|protected}0 here
protected %select{constructor|destructor}0 can only be used to %select{construct|destroy}0 a base class subobject
must name member using the type of the current context %0
can only access this member on an object of type %0
declared with %0 attribute here
allocated with 'new%select{[]|}0' here
lookup in the object type %0 refers here
candidate found by name lookup is %q0
inherited from base class %0 here
member type %0 found by ambiguous name lookup
because of ambiguity in conversion %diff{of $ to $|between types}0,1
use %select{__bridge_retained|CFBridgingRetain call}1 to make an ARC object available as a +1 %0
use %select{__bridge_transfer|CFBridgingRelease call}1 to transfer ownership of a +1 %0 into ARC
use __bridge_retained with C-style cast to make an ARC object available as a +1 %0
use __bridge_transfer with C-style cast to transfer ownership of a +1 %0 into ARC
declaration in interface is not in the '%select{alloc|copy|init|new}0' family because %select{its result type is not an object pointer|its result type is unrelated to its receiver type}1
block will be retained by %select{the captured object|an object strongly retained by the captured object}0
array %0 declared here
conversion to %select{integral|enumeration}0 type %1 declared here
constraint '%0' is already present here
use constraint modifier "%0"
type %0 is incomplete
%select{and|because}0 '%1' evaluated to false
%select{and|because}0 '%1' (%2 %3 %4) evaluated to false
previous %select{unmarked |}0overload of function is here
%0 has been explicitly marked %select{unavailable|deleted|deprecated}1 here
base class %0 specified here
did you mean to use __block %0?
called by %0
previous call is here%select{; set to nil to indicate it cannot be called afterwards|}0
%0 declared here
'trivial_abi' is disallowed on %0 because %select{its copy constructors and move constructors are all deleted|it is polymorphic|it has a base of a non-trivial class type|it has a virtual base|it has a __weak field|it has a field of a non-trivial class type}1
%select{category|class extension}0 conforms to protocol %1 which defines method %2
consider making the bitfield type %select{unsigned|signed}0
consider defining %0 with the '%1' calling convention
while checking constraint satisfaction for class template partial specialization '%0' required here
while checking constraint satisfaction for function '%0' required here
while checking constraint satisfaction for template '%0' required here
while checking constraint satisfaction for variable template partial specialization '%0' required here
explicitly declare getter %objcinstance0 with '%1' to return an 'unowned' object
in defaulted %sub{select_defaulted_comparison_kind}0 for %1 first required here
compatible type %0 specified here
%select{and|because}0 '%1' evaluated to false
while checking the satisfaction of concept '%0' requested here
conflicting %0 here
%select{data member %1|base class %2}0 declared here
add the %select{'require_constant_initialization' attribute|'constinit' specifier}0 to the initializing declaration here
while calculating associated constraint of template '%0' here
use 'static' to give inline function %0 internal linkage
call to %0 implicitly required by coroutine function here
call to '%select{initial_suspend|final_suspend}0' implicitly required by the %select{initial suspend point|final suspend point}0
the %select{1st|2nd|3rd}1 template parameter of %0 needs to be %select{a type|an integer or enum value}2
%0 needs to have exactly %1 template parameters
%0 needs to be instantiated from a class template with proper template arguments
annotate %select{%1|anonymous %1}0 with an availability attribute to silence this warning
this declaration is not a prototype; add %select{'void'|parameter declarations}0 to make it %select{a prototype for a zero-parameter function|one}0
function is a coroutine due to use of '%0' here
declared %select{'returns_nonnull'|'nonnull'}0 here
required by %select{'require_constant_initialization' attribute|'constinit' specifier}0 here
during template argument deduction for %select{class|variable}0 template %select{partial specialization |}1%2 %3
deduction guide declared %0 by intervening access specifier
member template declared %0 here
in instantiation of default argument for '%0' required here
in instantiation of default function argument expression for '%0' required here
defaulted %0 is implicitly deleted because implied %select{|'==' |'<' }1comparison %select{|for member %3 |for base class %3 }2is ambiguous
defaulted %0 is implicitly deleted because it would invoke a deleted comparison function%select{| for member %2| for base class %2}1
return type of defaulted 'operator<=>' cannot be deduced because return type %2 of three-way comparison for %select{|member|base class}0 %1 is not a standard comparison category type
selected 'operator<=>' for %select{|member|base class}0 %1 declared here
%select{|member|base class}0 %1 declared here
defaulted %0 is implicitly deleted because it would invoke a %select{private|protected}3 %4%select{ member of %6| member of %6 to compare member %2| to compare base class %2}1
defaulted %0 is implicitly deleted because there is no viable three-way comparison function for%select{| member| base class}1 %2
three-way comparison cannot be synthesized because there is no viable function for %select{'=='|'<'}0 comparison
non-constexpr comparison function would be used to compare %select{|member %1|base class %1}0
defaulted %0 is implicitly deleted because this non-rewritten comparison function would be the best match for the comparison
defaulted %0 is implicitly deleted because class %1 has a reference member
defaulted %0 is implicitly deleted because %2 is a %select{union-like class|union}1 with variant members
%0 defined here
conversion to pointer type %0
%select{copy|move}0 assignment operator of %1 is implicitly deleted because field %2 is of %select{reference|const-qualified}4 type %3
copy constructor of %0 is implicitly deleted because field %1 is of rvalue reference type %2
copy %select{constructor|assignment operator}0 is implicitly deleted because %1 has a user-declared move %select{constructor|assignment operator}2
%select{default constructor of|constructor inherited by}0 %1 is implicitly deleted because all %select{data members|data members of an anonymous union member}2 are const-qualified
%select{default constructor of|constructor inherited by}0 %1 is implicitly deleted because field %2 of %select{reference|const-qualified}4 type %3 would not be initialized
%select{default constructor of|copy constructor of|move constructor of|copy assignment operator of|move assignment operator of|destructor of|constructor inherited by}0 %1 is implicitly deleted because %select{base class %3|%select{||||variant }4field %3}2 %select{has %select{no|a deleted|multiple|an inaccessible|a non-trivial}4 %select{%select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor|%select{default|corresponding|default|default|default}4 constructor}0|destructor}5%select{||s||}4|is an ObjC pointer}6
function is implicitly deleted because its declared type does not match the type of an implicit %sub{select_special_member_kind}0
candidate ignored: %select{not a function template|not a member of the enclosing namespace; did you mean to explicitly qualify the specialization?}0
type %0 found by destructor name lookup
direct method %0 declared here
due to %0 being dllexported%select{|; try compiling in C++11 mode}1
asm operand name "%0" first referenced here
element %0 also has value %1
change this ',' to a ';' to call %0
%0 declared here
enum %0 was explicitly specialized here
declared here%select{ in module '%1'|}0
in evaluation of exception specification for %q0 needed here
explicit %select{constructor|deduction guide}0 declared here
explicit instantiation candidate function %q0 template here %1
while substituting explicitly-specified template arguments into function template %0 %1
'template<>' header not required for explicitly-specialized class %0 declared here
%select{and|because}0 type constraint '%1' was not satisfied:
%select{and|because}0 %1 does not satisfy %2:
%select{and|because}0 '%1' would be invalid: %2
%select{and|because}0 '%1' would be invalid
%select{and|because}0 '%1' may throw an exception
%select{and|because}0 '%1' would be invalid: %2
%select{and|because}0 '%1' would be invalid
declared %select{in global scope|with C language linkage}0 here
mark %0 as '%select{final|sealed}1' to silence this warning
final overrider of %q0 in %1
initialized flexible array member %0 is here
selected '%select{begin|end}0' %select{function|template }1%2 with iterator type %3
in implicit call to 'operator%select{!=|*|++}0' for iterator of type %1
member is not a candidate because range type %0 has no '%select{end|begin}1' member
did you mean to use '%0'?
%0 is not defined, but forward declared here; conversion would be valid if it was derived from %1
found near match '%0'
from 'diagnose_if' attribute on %0:
did you mean %0?
while substituting deduced template arguments into function template %0 %1
in instantiation of function template specialization %q0 requested here
function template %q0 matches specialization %1
or because setter is declared here, but no getter method %0 is found
inline assembly label %0 declared here
hidden overloaded virtual function %q0 declared here%select{|: different classes%diff{ ($ vs $)|}2,3|: different number of parameters (%2 vs %3)|: type mismatch at %ordinal2 parameter%diff{ ($ vs $)|}3,4|: different return type%diff{ ($ vs $)|}2,3|: different qualifiers (%2 vs %3)|: different exception specifications}1
conversion to %select{integral|enumeration}0 type %1 declared here
field of illegal %select{type|pointer type}0 %1 declared here
when implemented by class %0
implicit %sub{select_special_member_kind}0 inferred target collision: call to both %select{__device__|__global__|__host__|__host__ __device__}1 and %select{__device__|__global__|__host__|__host__ __device__}2 members
%0 is an implicit parameter
in implicit initialization of binding declaration %0
while declaring the implicit %sub{select_special_member_kind}1 for %0
when looking up '%select{begin|end}0' function for range expression of type %1
in implicit initialization of %select{array element %1 with omitted initializer|field %1 with omitted initializer|trailing array elements in runtime-sized array new}0
in initialization of temporary of type %0 created to list-initialize this reference
include the header <%0> or explicitly provide a declaration for '%1'
conformance of forward class %0 to protocol %1 can not be confirmed
possible target of %select{indirect|asm}0 goto statement
initializing field %0 with default member initializer
%select{field|base class}0 %1 will be initialized after %select{field|base}2 %3
insert '%0;' to silence this warning
add an explicit instantiation declaration to suppress this warning if %q0 is explicitly instantiated in another translation unit
(skipping %0 context%s0 in backtrace; use -ftemplate-backtrace-limit=0 to see all)
%select{implicit|explicit}0 instantiation first required here
%select{implicitly |}2captured%select{| by reference}3%select{%select{ due to use|}2 here| via initialization of lambda capture %0}1
default capture by %select{value|reference}0
capture %0 by %select{value|reference}1
%select{%select{reference|'std::initializer_list'}0 member|member with %select{reference|'std::initializer_list'}0 subobject}1 declared here
type of %ordinal0 parameter of local declaration does not match definition%diff{ ($ vs $)|}1,2
%select{via initialization of|binding reference}0 variable %select{%2 |}1here
the other acquisition of %0 '%1' is here
%0 acquired here
use '%0' for a bitwise operation
add parentheses after the '!' to evaluate the %select{comparison|bitwise operator}0 first
%select{decremented|incremented}0 here
member %0 declared here
member declaration does not match because it %select{is|is not}0 const qualified
type of %ordinal0 parameter of member declaration does not match definition%diff{ ($ vs $)|}1,2
member %0 first declared here
in %select{implicit|defaulted}0 %sub{select_special_member_kind}1 for %2 first required here
did you mean to compare the result of %0 instead?
method %0 declared here
compiler has implicitly changed method %0 return type
method %0 is used for the forward class
%0 begins here
target function has calling convention %1 (expected %0)
%0 declared here
target function %select{is a member of different class%diff{ (expected $ but has $)|}1,2|has different number of parameters (expected %1 but has %2)|has type mismatch at %ordinal3 parameter%diff{ (expected $ but has $)|}1,2|has different return type%diff{ ($ expected but has $)|}1,2}0
target %select{constructor|destructor}0 is declared here
namespace %0 defined here
consider using vld1_%0%1() to initialize a vector from memory, or vcreate_%0%1() to initialize from an integer constant
consider using vld1q_%0%1() to initialize a vector from memory, or vcombine_%0%1(vcreate_%0%1(), vcreate_%0%1()) to initialize from integer constants
%select{and|because}0 '%1' would be invalid: %2
%select{and|because}0 '%1' would be invalid
next %select{instance variable declaration|synthesized instance variable}0 is here
type is not C-compatible due to this %select{base class|default member initializer|lambda expression|friend declaration|member declaration}0
non-deducible template parameter %0
%0 is not literal because it has base class %1 of non-literal type
%0 is not literal because it has data member %1 of %select{non-literal|volatile}3 type %2
incomplete type %0 is not a literal type
%0 is not literal because it is not an aggregate and has no constexpr constructors other than copy or move constructors
%0 is not literal because its destructor is not constexpr
%0 is not literal because it has a non-trivial destructor
%0 is not literal because it has a user-provided destructor
%select{struct|interface|class}0 with virtual base %plural{1:class|:classes}1 is not a literal type
%select{%2 has subobjects that are|%3 has type %2 that is}0 non-trivial to %select{default-initialize|destruct|copy}1
non-usual %0 declared here
because field %0 has an initializer
field is non-trivial to %select{copy|default-initialize}0
because type %0 has a virtual %select{member function|base class}1
because no %select{<<ERROR>>|constructor|constructor|assignment operator|assignment operator|<<ERROR>>}2 can be used to %select{<<ERROR>>|copy|move|copy|move|<<ERROR>>}2 %select{base class|field|an object}0 of type %3
because %select{base class of |field of |}0type %1 has no default constructor
because type %0 has a member with %select{no|no|__strong|__weak|__autoreleasing}1 ownership
because its parameter is %diff{of type $, not $|of the wrong type}2,3
because the function selected to %select{construct|copy|move|copy|move|destroy}2 %select{base class|field}0 of type %1 is not trivial
because %select{base class of |field of |}0type %1 has a user-provided %sub{select_special_member_kind}2
destructor for %0 is not trivial because it is virtual
%0 should be declared prior to the call site%select{| or in %2| or in an associated namespace of one of its arguments}1
%0 is not a structural type because it has a mutable non-static data member
%0 is not a structural type because it has a %select{non-static data member|base class}1 that is not public
%0 is not a structural type because it has a non-static data member of rvalue reference type
%0 is not a structural type because it has a %select{non-static data member|base class}1 of non-structural type %2
insert '%select{_Nonnull|_Nullable|_Null_unspecified}0' if the %select{pointer|block pointer|member pointer|array parameter}1 %select{should never be null|may be null|should not declare nullability}0
%0 specified here
use nullability type specifier %0 to affect the innermost pointer type of %1
%0 declared here
%select{first|second|third}0 parameter has unexpected type %1 (should be %2)
method returns unexpected type %0 (should be an object type)
type parameter %0 declared here
method %0 that returns %1 declared here
%select{expected assignment expression|expected compound statement|expected exactly two expression statements|expected in right hand side of the first expression}0
%select{expected an expression statement|expected built-in assignment operator|expected expression of scalar type|expected lvalue expression}0
%select{expected an expression statement|expected built-in binary or unary operator|expected unary decrement/increment operation|expected expression of scalar type|expected assignment expression|expected built-in binary operator|expected one of '+', '*', '-', '/', '&', '^', '%|', '<<', or '>>' built-in operations|expected in right hand side of expression}0
as specified in %select{'collapse'|'ordered'|'collapse' and 'ordered'}0 clause%select{||s}0
conversion to %select{integral|enumeration}0 type %1 declared here
%select{|previous }0'hint' clause with value '%1'
%select{|previous }0directive with no 'hint' clause specified
'%0' directive found here
defined as %0
memory order clause '%0' is specified here
implicitly determined as %0
loop step is expected to be %select{negative|positive}0 due to this condition
marked as 'device_type(%0)' here
%select{statement|directive}0 outside teams construct here
'ordered' clause%select{| with specified parameter}0
predefined trait '%0' used here
%select{static data member is predetermined as shared|variable with static storage duration is predetermined as shared|loop iteration variable is predetermined as private|loop iteration variable is predetermined as linear|loop iteration variable is predetermined as lastprivate|constant variable is predetermined as shared|global variable is predetermined as shared|non-shared variable in a task construct is predetermined as firstprivate|variable with automatic storage duration is predetermined as private}0%select{|; perhaps you forget to enclose 'omp %2' directive into a parallel or another task region?}1
'%0' clause is specified here
previous '%0' directive used here
'%0' clause used here
'%0' previously encountered here
%0 clause previously used here
previously declared '%0' here
'operator->' declared here produces an object of type %0
(skipping %0 'operator->'%s0 in backtrace)
built-in candidate %0
candidate %sub{select_ovl_candidate_kind}0,1,3%select{| has different class%diff{ (expected $ but has $)|}5,6| has different number of parameters (expected %5 but has %6)| has type mismatch at %ordinal5 parameter%diff{ (expected $ but has $)|}6,7| has different return type%diff{ ($ expected but has $)|}5,6| has different qualifiers (expected %5 but found %6)| has different exception specification}4
candidate %sub{select_ovl_candidate_kind}0,1,2 not viable: requires%select{ at least| at most|}3 %4 argument%s4, but %5 %plural{1:was|:were}5 provided
candidate %sub{select_ovl_candidate_kind}0,1,2 not viable: %select{requires at least|allows at most single|requires single}3 argument %4, but %plural{0:no|:%5}5 arguments were provided
candidate %sub{select_ovl_candidate_kind}0,1,2 not viable: cannot %select{pass pointer to|bind reference in}5 %3 %select{as a pointer to|to object in}5 %4 in %ordinal6 argument
candidate %sub{select_ovl_candidate_kind}0,1,2 not viable: 'this' object is in %3, but method expects object in %4
candidate %sub{select_ovl_candidate_kind}0,1,2 not viable: cannot implicitly convert argument %diff{of type $ to $|type to parameter type}3,4 for %select{%ordinal6 argument|object argument}5 under ARC
candidate %sub{select_ovl_candidate_kind}0,1,2 not viable: cannot %select{convert from|convert from|bind}3 %select{base class pointer|superclass|base class object of type}3 %4 to %select{derived class pointer|subclass|derived class reference}3 %5 for %ordinal6 argument
candidate %sub{select_ovl_candidate_kind}0,1,2 not viable: no known conversion %diff{from $ to $|from argument type to parameter type}3,4 for %select{%ordinal6 argument|object argument}5%select{|; dereference the argument with *|; take the address of the argument with &|; remove *|; remove &}7
candidate %sub{select_ovl_candidate_kind}0,1,2 not viable: cannot convert argument of incomplete type %diff{$ to $|to parameter type}3,4 for %select{%ordinal6 argument|object argument}5%select{|; dereference the argument with *|; take the address of the argument with &|; remove *|; remove &}7
candidate %sub{select_ovl_candidate_kind}0,1,2 not viable: %ordinal5 argument (%3) would lose %select{const|restrict|const and restrict|volatile|const and volatile|volatile and restrict|const, volatile, and restrict}4 qualifier%select{||s||s|s|s}4
candidate %sub{select_ovl_candidate_kind}0,1,2 not viable: 'this' argument has type %3, but method is not marked %select{const|restrict|const or restrict|volatile|const or volatile|volatile or restrict|const, volatile, or restrict}4
candidate %sub{select_ovl_candidate_kind}0,1,2 not viable: %select{%ordinal7|'this'}6 argument (%3) has %select{no|__weak|__strong}4 ownership, but parameter has %select{no|__weak|__strong}5 ownership
candidate %sub{select_ovl_candidate_kind}0,1,2 not viable: cannot convert initializer list argument to %4
candidate %sub{select_ovl_candidate_kind}0,1,2 not viable: no overload of %4 matching %3 for %ordinal5 argument
candidate %sub{select_ovl_candidate_kind}0,1,2 not viable: %select{%ordinal7|'this'}6 argument (%3) has %select{no|__unsafe_unretained|__strong|__weak|__autoreleasing}4 ownership, but parameter has %select{no|__unsafe_unretained|__strong|__weak|__autoreleasing}5 ownership
candidate %sub{select_ovl_candidate_kind}0,1,2 not viable: call to %select{__device__|__global__|__host__|__host__ __device__|invalid}3 function from %select{__device__|__global__|__host__|__host__ __device__|invalid}4 function
candidate %sub{select_ovl_candidate_kind}0,1,2 not viable: %ordinal5 argument (%3) would lose __unaligned qualifier
candidate %sub{select_ovl_candidate_kind}0,1,2 not viable: expects an %select{lvalue|rvalue}5 for %select{%ordinal4 argument|object argument}3
candidate %sub{select_ovl_candidate_kind}0,1,2 not viable: constraints not satisfied
candidate template ignored: deduced type %diff{$ of %select{|element of }4%ordinal0 parameter does not match adjusted type $ of %select{|element of }4argument|of %select{|element of }4%ordinal0 parameter does not match adjusted type of %select{|element of }4argument}1,2%3
candidate %sub{select_ovl_candidate_kind}0,1,2 has been %select{explicitly made unavailable|explicitly deleted|implicitly deleted}3
candidate template ignored: disabled by %0%1
candidate disabled: %0
candidate template ignored: requirement '%0' was not satisfied%1
explicit %select{constructor|conversion function|deduction guide}0 is not a candidate%select{| (explicit specifier evaluates to true)}1
candidate template ignored: invalid explicitly-specified argument for template parameter %0
candidate template ignored: invalid explicitly-specified argument for %ordinal0 template parameter
candidate address cannot be taken because parameter %0 has pass_object_size attribute
candidate %select{constructor|template}0 ignored: instantiation %select{takes|would take}0 its own class type by value
candidate constructor ignored: cannot be used to construct an object in address space %0
candidate template ignored: couldn't infer template argument %0
candidate template ignored: deduced too few arguments for expanded pack %0; no argument for %ordinal1 expanded parameter in deduced argument pack %2
candidate template ignored: deduced %select{conflicting types|conflicting values|conflicting templates|packs of different lengths}0 for parameter %1%diff{ ($ vs. $)|}2,3
candidate template ignored: deduced values %diff{of conflicting types for parameter %0 (%1 of type $ vs. %3 of type $)|%1 and %3 of conflicting types for parameter %0}2,4
constructor from base class %0 inherited here
candidate %select{constructor|template}0 ignored: inherited constructor cannot be used to %select{copy|move}1 object
candidate template ignored: could not match %diff{$ against $|types}0,1
candidate template ignored: could not match %q0 against %q1
candidate template ignored: substitution failure%0%1
candidate template ignored: cannot deduce a type for %0 that would make %2 equal %1
candidate template ignored: constraints not satisfied%0
conversion candidate of type %0
remaining %0 candidate%s0 omitted; pass -fshow-overloads=all to show them
declared with index %0 here
passing argument to parameter %0 here
parameter pack %0 declared here
parameter of type %0 is declared here
%0 has been marked as being introduced in %1 %2 here, but the deployment target is %1 %3
partial specialization matches %0
%0
pointer %0 declared here
place parentheses around the %0 expression to evaluate it first
place parentheses around the '%0' expression to silence this warning
module loaded from '%0'
previous declaration of class template partial specialization %0 is here
previously declared '%1' here
%0 is a builtin with type %1
%0 declared here
for type %0
previous initialization for field %0 is here
previous initialization %select{|with side effects }0is here%select{| (side effects will not occur at run time)}0
previously defined as an alias for %0
did you mean to call the %0 method?
while substituting prior template arguments into %select{non-type|template}0 template parameter%1 %2
property %0 is declared %select{deprecated|unavailable|partial}1 here
protocol %0 has no definition
it could also be property %select{of type %1|without attribute '%1'|with attribute '%1'|with getter %1|with setter %1}0 declared here
qualified call to %0::%1 is treated as a virtual call to %1 due to -fapple-kext
unimplemented pure virtual method %0 in %1
add a variable name to declare a %0 initialized with %1
'%0' included multiple times, additional include site here
'%0' included multiple times, additional include site in header from module '%1'
%select{reference|pointer}0 member declared here
%select{const|reference}0 member %1 will never be initialized
%0 returns a reference
use 'static_cast' to adjust the pointer correctly while %select{upcasting|downcasting}0
%select{overridden|current}0 method is explicitly declared 'instancetype'%select{| and is expected to return an instance of its class type}0
%select{overridden|current}0 method is part of the '%select{|alloc|copy|init|mutableCopy|new|autorelease|dealloc|finalize|release|retain|retainCount|self}1' method family%select{| and is expected to return an instance of its class type}0
%select{class|instance}0 method %1 is assumed to return an instance of its receiver type (%2)
remove the call to '%0' since unsigned values cannot be negative
use function '%0' instead
%select{function|method|block}0 has been explicitly marked sentinel here
%select{and|because}0 %1 does not satisfy %2
declare 'static' if the %select{variable|function}0 is not intended to be used outside of this translation unit
did you mean %select{struct|interface|class}0 here?
because substituted constraint expression is ill-formed%0
%select{parenthesize the third argument|cast the second argument to 'int'}0 to silence
conversion to %select{integral|enumeration}0 type %1
tail call required by %0 attribute here
non-type template argument refers to %select{function|object}0 here
template argument refers to function template %0, here
class template %0 was explicitly specialized here
in instantiation of template class %q0 requested here
class template %0 was instantiated here
%select{function template|class template|variable template|type alias template|template template parameter}0 %1 declared here
in instantiation of enumeration %q0 requested here
in instantiation of exception specification for %0 requested here
in instantiation of member class %q0 requested here
in instantiation of member function %q0 requested here
template non-type parameter has a different type %0 in template argument
previous non-type template parameter with type %0 is here
in instantiation of default member initializer %q0 requested here
%select{too few|too many}0 template parameters in template template argument
previous %select{template type|non-type template|template template}0 parameter%select{| pack}1 declared here
%select{template type|non-type template|template template}0 parameter%select{| pack}1 does not match %select{template type|non-type template|template template}0 parameter%select{ pack|}1 in template argument
previous template %select{declaration|template parameter}0 is here
in instantiation of static data member %q0 requested here
in instantiation of template type alias %0 requested here
in instantiation of variable template specialization %q0 requested here
thread warning in function %0
%select{destructor|deallocator}0 has a %select{non-throwing|implicit non-throwing}1 exception specification
required alignment of type %0 (%1 bytes) is larger than the supported alignment of C++ exception objects on this target (%2 bytes)
%select{alignment|size}0 of first field is %1 bits
%0 is incomplete
%select{and|because}0 '%1' would be invalid: %2
%select{and|because}0 '%1' would be invalid
%select{function %1 which returns const-qualified type %2 declared here|variable %1 declared const here|%select{non-|}1static data member %2 declared const here|member function %q1 is declared const here|%select{|nested }1data member %2 declared const here}0
%select{first|second}0 operand was implicitly converted to type %1
type is given name %0 for linkage purposes by this %select{typedef|alias}1 declaration
referenced member %0 is declared here
referenced %0 is declared here
enclose %0 in %select{an @available|a __builtin_available}1 check to silence this warning
remove the %select{'%1' if its condition|condition if it}0 is always %select{false|true}2
during field initialization in %select{this|the implicit default}0 constructor
%select{uninitialized use occurs|variable is captured by block}0 here
%0 released here
%select{declaration|definition|default argument declared|explicit specialization declared|partial specialization declared}0 here is not %select{visible|reachable|reachable|reachable|reachable|reachable}0
use non-reference type %0
use reference type %0 to prevent copying
use non-reference type %0 to make construction explicit or type %1 to prevent copying
%select{|previous }0using declaration
use %select{an alias declaration|a typedef declaration|a reference|a const variable|a constexpr variable}0 instead
%select{|previous }0using-enum declaration
in value-initialization of type %0 here
variable %0 is declared here
variable %0 is%select{| explicitly}1 captured here
initialize the variable %0 to silence this warning
%select{%1 is a virtual base class of base class %2 declared here|virtual base class %1 declared here}0
widen this field to %0 bits to store all values of %1
within field of type %0 declared here
replace expression with '%0' %select{|or use 'xor' instead of '^' }1to silence this warning
non-virtual member function marked '%0' hides virtual member %select{function|functions}1
only virtual member functions can be marked '%0'
%select{arithmetic between|bitwise operation between|comparison of|conditional expression between|compound assignment of}0
%select{<ERROR>|equality|three-way|equality|relational}0 comparison operator
%select{copying variable|copying parameter|initializing template parameter|returning object|initializing statement expression result|throwing object|copying member subobject|copying array element|allocating object|copying temporary|initializing base subobject|initializing vector element|capturing value}0
%select{function|function|function (with reversed parameter order)|constructor|constructor (the implicit default constructor)|constructor (the implicit copy constructor)|constructor (the implicit move constructor)|function (the implicit copy assignment operator)|function (the implicit move assignment operator)|function (the implicit 'operator==' for this 'operator<=>)'|inherited constructor}0%select{| template| %2}1
%select{default constructor|copy constructor|move constructor|copy assignment operator|move assignment operator|destructor}0
%select{struct|interface|union|class|enum}0
%0-bit %select{signed|unsigned}1 value
absolute value function %0 given an argument of type %1 but has parameter of type %2 which may cause truncation of value
abstract class is marked '%select{final|sealed}0'
initializer for virtual base class %0 of abstract class %1 will never be used
type of property %0 does not match type of accessor %1
acquiring %0 '%1' requires negative capability '%2'
%0 '%1' must be acquired before '%2'
Cycle in acquired_before/after dependencies, starting with '%0'
operator '%0' has lower precedence than '%1'; '%1' will be evaluated first
reference cannot be bound to dereferenced null pointer in well-defined C++ code; comparison may be assumed to always evaluate to %select{true|false}0
%select{aligning a value|the result of checking whether a value is aligned}0 to 1 byte is %select{a no-op|always true}0
use of function %0 is discouraged; there is no way to check for failure but failure may still occur, resulting in a possibly exploitable security vulnerability
multiple suitable %0 functions for %1; no 'operator delete' function will be invoked if initialization throws an exception
ARC %select{unused|__unsafe_unretained|__strong|__weak|__autoreleasing}0 lifetime qualifier on return type is ignored
assigning %select{array literal|dictionary literal|numeric literal|boxed expression|<should not happen>|block literal}0 to a weak %select{property|variable}1; object will be released after assignment
%select{destination for|source of}0 this %1 call is a pointer to ownership-qualified type %2
weak %select{variable|property|implicit property|instance variable}0 %1 may be accessed multiple times in this %select{function|method|block|lambda}2 and may be unpredictably set to nil; assign to a strong variable to keep the object alive
weak %select{variable|property|implicit property|instance variable}0 %1 is accessed multiple times in this %select{function|method|block|lambda}2 but may be unpredictably set to nil; assign to a strong variable to keep the object alive
capturing %0 strongly in this block is likely to lead to a retain cycle
assigning retained object to %select{weak|unsafe_unretained}0 %select{property|variable}1; object will be released after assignment
method parameter of type %0 with no explicit ownership
argument value %0 is outside the valid range [%1, %2]
%sub{select_arith_conv_kind}0 %select{floating-point|enumeration}1 type %2 %plural{2:with|4:from|:and}0 %select{enumeration|floating-point}1 type %3
%sub{select_arith_conv_kind}0 %select{floating-point|enumeration}1 type %2 %plural{2:with|4:from|:and}0 %select{enumeration|floating-point}1 type %3 is deprecated
%sub{select_arith_conv_kind}0 different enumeration types%diff{ ($ and $)|}1,2
%sub{select_arith_conv_kind}0 different enumeration types%diff{ ($ and $)|}1,2 is deprecated
%sub{select_arith_conv_kind}0 different enumeration types%diff{ ($ and $)|}1,2
%sub{select_arith_conv_kind}0 different enumeration types%diff{ ($ and $)|}1,2 is deprecated
array index %0 is past the end of the array (which contains %1 element%s2)
array index %0 refers past the last possible element for an array in %1-bit address space containing %2-bit (%3-byte) elements (max possible %4 element%s5)
array index %0 is before the beginning of the array
ignored asm label '%0' on automatic variable
requested alignment must be %0 bytes or smaller; maximum alignment assumed
unknown assumption string '%0'; attribute is potentially ignored
unknown assumption string '%0' may be misspelled; attribute is potentially ignored, did you mean '%1'?
the argument to %0 has side effects that will be discarded
%select{@available|__builtin_available}0 does not guard availability here; use if (%select{@available|__builtin_available}0) instead
writable atomic property %0 cannot pair a synthesized %select{getter|setter}1 with a user defined %select{getter|setter}2
'abi_tag' attribute on %select{non-inline|anonymous}0 namespace ignored
consumed analysis attribute is attached to member of class %0 which isn't marked as consumable
%0 attribute cannot be applied to this declaration
%0 attribute cannot be applied to a %select{function|method}1 with no parameters
%0 attribute argument must be a string literal specifying a Swift function name
%0 attribute for getter must not have any parameters besides 'self:'
%0 attribute has invalid identifier for the %select{base|context|parameter}1 name
%0 attribute is missing parameter label clause
%0 attribute cannot specify more than one 'self:' parameter
too %select{few|many}0 parameters in the signature specified by the %1 attribute (expected %2; got %3)
%0 attribute for setter must have one parameter for new value
%0 attribute for 'subscript' getter cannot have a 'newValue:' parameter
%0 attribute for 'subscript' must %select{be a getter or setter|have at least one parameter|have a 'self:' parameter}1
%0 attribute for 'subscript' setter cannot have multiple 'newValue:' parameters
%0 attribute for 'subscript' setter must have a 'newValue:' parameter
attribute %0 after definition is ignored
%0 attribute parameter %1 is negative and will be ignored
propagating dll attribute to %select{already instantiated|explicitly specialized}0 base class template without dll attribute is not supported
redeclaration of %q0 should not add %q1 attribute
attribute %0 has no effect when annotating an 'if constexpr' statement
attribute %0 has no effect when annotating an infinite loop
%0 attribute can only be applied to instance variables or properties
%0 attribute ignored
%0 attribute ignored for field of type %1
%0 attribute ignored on inline function
%0 attribute ignored on a non-definition declaration
'%0' attribute cannot be specified on a definition
'%0' is not a valid builtin name for %1
%0 attribute ignored when parsing type
%0 attribute only applies to a pointer or reference (%1 is invalid)
%0 attribute only applies to%select{| constant}1 pointer arguments
%0 attribute only applies to return values that are pointers
%0 attribute only applies to return values that are pointers or references
#pragma %0(".drectve") has undefined behavior, use #pragma comment(linker, ...) instead
'sentinel' attribute only supported for variadic %select{functions|blocks}0
%0 attribute argument not supported: %1
unknown visibility %0
attribute %0 cannot be applied to %select{functions|Objective-C method}1 without return value
%0 attribute only applies to %select{functions|unions|variables and functions|functions and methods|functions, methods and blocks|functions, methods, and parameters|variables|variables and fields|variables, data members and tag types|types and namespaces|variables, functions and classes|kernel functions|non-K&R-style functions}1
%0 attribute only applies to %1
conflicting attributes %0 are ignored
readonly IBOutlet property %0 when auto-synthesized may not work correctly with 'nib' loader
auto property synthesis will not synthesize property %0 declared in protocol %1
'auto' deduced as 'id' in declaration of %0
auto property synthesis will not synthesize property %0; it will be implemented by its superclass, use @dynamic to acknowledge intention
autosynthesized property %0 will use %select{|synthesized}1 instance variable %2, not existing instance variable %3
ignoring availability attribute %select{on '+load' method|with constructor attribute|with destructor attribute}0
unknown platform %0 in availability macro
feature cannot be %select{introduced|deprecated|obsoleted}0 in %1 version %2 before it was %select{introduced|deprecated|obsoleted}3 in version %4; attribute ignored
%select{reinterpret_cast|C-style cast}0 from %1 to %2 changes address space of nested pointers
cast from function call of type %0 to non-matching type %1
receiver type %0 is not 'id' or interface pointer, consider casting it to 'id'
base class %0 is uninitialized when used here to access %q1
binding reference member %0 to stack allocated %select{variable|parameter}2 %1
bit-field %0 is not wide enough to store all enumerators of %1
width of bit-field %0 (%1 bits) exceeds the width of its type; value will be truncated to %2 bit%s2
bitwise negation of a boolean expression%select{;| always evaluates to 'true';}0 did you mean logical negation?
'%0' within '%1'
attribute %0 ignored, because it cannot be applied to omitted return type
'%0' qualifier on omitted return type %1 has no effect
braces around %select{scalar |}0initializer
'%0' will always overflow; destination buffer has size %1, but size argument is %2
use of unknown builtin %0
call to pure virtual member function %0 has undefined behavior; overrides of %0 in subclasses are not available in the %select{constructor|destructor}1 of %2
too %select{few|many}0 arguments in call to %1
%0 parameter marked 'called_once' is called twice
%select{|captured }1%0 parameter marked 'called_once' is never called
%0 parameter marked 'called_once' is never %select{used|called}1 when %select{taking true branch|taking false branch|handling this case|none of the cases applies|entering the loop|skipping the loop|taking one of the branches}2
cannot pass object of %select{non-POD|non-trivial}0 type %1 through variadic %select{function|block|method|constructor}2; call will abort at runtime
overflow converting case value to switch condition type (%0 to %1)
cast from %0 to %1 increases required alignment from %2 to %3
cast between incompatible calling conventions '%0' and '%1'; calls through this pointer may abort at runtime
cast %diff{from $ to $ |}0,1converts to incompatible function type
nonnull %select{function call|parameter}0 '%1' will evaluate to 'true' on first encounter
cast of type %0 to %1 is deprecated; use sel_getName instead
cast from %0 to %1 drops %select{const and volatile qualifiers|const qualifier|volatile qualifier}2
cast from %0 to %1 must have all intermediate pointers const qualified to be safe
function with no prototype cannot use the %0 calling convention
%0 calling convention is not supported %select{for this target|on variadic function|on constructor/destructor|on builtin function}1
cannot refer to a non-static member from the handler of a %select{constructor|destructor}0 function try block
class method %objcclass0 not found (return type defaults to 'id')
class method %objcclass0 not found (return type defaults to 'id'); did you mean %objcclass2?
passing union across security boundary via %select{parameter %1|return value}0 may leak information
collection expression type %0 may not respond to %1
%select{self-|array }0comparison always evaluates to %select{a constant|true|false|'std::strong_ordering::equal'}1
bitwise comparison always evaluates to %select{false|true}0
%sub{select_arith_conv_kind}0 different enumeration types%diff{ ($ and $)|}1,2
%sub{select_arith_conv_kind}0 different enumeration types%diff{ ($ and $)|}1,2 is deprecated
comparison of different enumeration types in switch statement%diff{ ($ and $)|}0,1
%select{|captured }1completion handler is never called
completion handler is never %select{used|called}1 when %select{taking true branch|taking false branch|handling this case|none of the cases applies|entering the loop|skipping the loop|taking one of the branches}2
%sub{select_arith_conv_kind}0 different enumeration types%diff{ ($ and $)|}1,2
%sub{select_arith_conv_kind}0 different enumeration types%diff{ ($ and $)|}1,2 is deprecated
conflicting distributed object modifiers on parameter type in declaration of %0
conflicting parameter types in declaration of %0%diff{: $ vs $|}1,2
conflicting distributed object modifiers on return type in declaration of %0
conflicting return type in declaration of %0%diff{: $ vs $|}1,2
conflicting distributed object modifiers on parameter type in implementation of %0
conflicting parameter types in implementation of %0%diff{: $ vs $|}1,2
conflicting distributed object modifiers on return type in implementation of %0
conflicting return type in implementation of %0%diff{: $ vs $|}1,2
conversion function converting %0 to its base class %1 will never be used
conversion function converting %0 to itself will never be used
conversion function converting %0 to %1 will never be used
return type of 'coroutine_handle<>::address should be 'void*' (have %0) in order to get capability with existing async C API.
%0 is required to declare the member 'unhandled_exception()' when exceptions are enabled
%select{destination for|source of|first operand of|second operand of}0 this %1 call is a pointer to record %2 that is not trivial to %select{primitive-default-initialize|primitive-copy}3
%0 may not intend to support class template argument deduction
constructor parameter %0 shadows the field %1 of %2
use of this statement in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++14
variable declaration in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++14
type definition in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++14
attribute %0 ignored, because it cannot be applied to a type
class template argument deduction is incompatible with C++ standards before C++17%select{|; for compatibility, use explicit type name %1}0
non-type template parameters declared with %0 are incompatible with C++ standards before C++17
use of this statement in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++20
function try block in constexpr %select{function|constructor}0 is incompatible with C++ standards before C++20
uninitialized variable in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++20
decomposition declaration declared %plural{1:'%1'|:with '%1' specifiers}0 is incompatible with C++ standards before C++20
explicitly defaulting this %sub{select_special_member_kind}0 with a type different from the implicit type is incompatible with C++ standards before C++20
mangled name of %0 will change in C++17 due to non-throwing exception specification in function signature
%select{default construction|assignment}0 of lambda is incompatible with C++ standards before C++20
non-type template parameter of type %0 is incompatible with C++ standards before C++20
member using declaration naming non-class '%0' enumerator is incompatible with C++ standards before C++20
aggregate initialization of type %0 with user-declared constructors is incompatible with C++20
implicit conversion from array size expression of type %0 to %select{integral|enumeration}1 type %2 is incompatible with C++98
initializing %0 from an empty initializer list is incompatible with C++98
befriending enumeration type %0 is incompatible with C++98
jump from this %select{indirect|asm}0 goto statement to one of its possible targets is incompatible with C++98
use of non-static data member %0 in an unevaluated context is incompatible with C++98
non-class friend type %0 is incompatible with C++98
%select{anonymous struct|union}0 member %1 with a non-trivial %sub{select_special_member_kind}2 is incompatible with C++98
passing object of trivial but non-POD type %0 through variadic %select{function|block|method|constructor}1 is incompatible with C++98
static data member %0 in union is incompatible with C++98
%sub{select_initialized_entity_kind}1 of type %2 when binding a reference to a temporary would %select{invoke an inaccessible constructor|find no viable constructor|find ambiguous constructors|invoke a deleted constructor}0 in C++98
local type %0 as template argument is incompatible with C++98
non-type template argument referring to %select{function|object}0 %1 with internal linkage is incompatible with C++98
befriending %1 without '%select{struct|interface|union|class|enum}0' keyword is incompatible with C++98
'%0' type specifier is incompatible with C++98
initializing pointer member %0 to point to a temporary object whose lifetime is shorter than the lifetime of the constructed object
%select{reference|backing array for 'std::initializer_list'}2 %select{|subobject of }1member %0 %select{binds to|is}2 a temporary object whose lifetime is shorter than the lifetime of the constructed object
%select{temporary %select{whose address is used as value of|%select{|implicitly }2bound to}4 %select{%select{|reference }4member of local variable|local %select{variable|reference}4}1|array backing %select{initializer list subobject of local variable|local initializer list}1}0 %select{%3 |}2will be destroyed at the end of the full-expression
declaration of %0 will not be visible outside of this function
declaration shadows a %select{local variable|variable in %2|static data member of %2|field of %2|typedef in %2|type alias in %2|structured binding}1
declaration shadows a %select{local variable|variable in %2|static data member of %2|field of %2|typedef in %2|type alias in %2|structured binding}1
ignoring __declspec(allocator) because the function return type %0 is not a pointer or reference type
attribute %0 is ignored, place it after "%select{class|struct|interface|union|enum}1" to apply attribute to type declaration
exception specifications of %select{return|argument}0 types differ
%plural{1:enumeration value %1 not explicitly handled in switch|2:enumeration values %1 and %2 not explicitly handled in switch|3:enumeration values %1, %2, and %3 not explicitly handled in switch|:%0 enumeration values not explicitly handled in switch: %1, %2, %3...}0
atomic by default property %0 has a user defined %select{getter|setter}1 (property should be marked 'atomic' if this is intended)
explicitly defaulted %sub{select_defaulted_comparison_kind}0 is implicitly deleted
explicitly defaulted %sub{select_special_member_kind}0 is implicitly deleted
constructor for %0 creates a delegation cycle
%select{delete|destructor}0 called on %1 that is abstract but has non-virtual destructor
'delete' applied to a pointer-to-array type %0 treated as 'delete[]'
deleting pointer to incomplete type %0 may cause undefined behavior
%select{delete|destructor}0 called on non-final %1 that has virtual functions but non-virtual destructor
%0 is deprecated
compound assignment to object of volatile-qualified type %0 is deprecated
definition of implicit copy %select{constructor|assignment operator}1 for %0 is deprecated because it has a user-declared copy %select{assignment operator|constructor}1
definition of implicit copy %select{constructor|assignment operator}1 for %0 is deprecated because it has a user-declared destructor
definition of implicit copy %select{constructor|assignment operator}1 for %0 is deprecated because it has a user-provided copy %select{assignment operator|constructor}1
definition of implicit copy %select{constructor|assignment operator}1 for %0 is deprecated because it has a user-provided destructor
implementing deprecated %select{method|class|category}0
%0 may be deprecated because the receiver type is unknown
%0 currently has no effect on a using declaration
%select{decrement|increment}0 of object of volatile-qualified type %1 is deprecated
%0 is deprecated: %1
use of result of assignment to object of volatile-qualified type %0 is deprecated
conversion from string literal to %0 is deprecated
volatile-qualified parameter type %0 is deprecated
volatile-qualified return type %0 is deprecated
dereferencing %0; was declared with a 'noderef' type
%0 overrides a destructor but is not marked 'override'
%0
instance variable %0 is being directly accessed
expression does not compute the number of elements in this array; element type is %0, not %1
'%0' will return the size of the pointer, not the array itself
%q0 redeclared inline; %1 attribute ignored
double precision constant requires %select{cl_khr_fp64|cl_khr_fp64 and __opencl_c_fp64}0, casting to single precision
acquiring %0 '%1' that is already held
attribute %0 is already applied with different arguments
attribute %0 is already applied
element %0 has been implicitly assigned %1 which another element has been assigned
multiple declarations of method %0 found and ignored
duplicate protocol definition of %0 is ignored
%select{destination for|source of|first operand of|second operand of}0 this %1 call is a pointer to %select{|class containing a }2dynamic class %3; vtable pointer will be %select{overwritten|copied|moved|compared}4
exception of type %0 will be caught by earlier handler
expecting %0 '%1' to be held at start of each loop
expecting %0 '%1' to be held at the end of function
explicit instantiation of %0 that occurs after an explicit specialization has no effect
explicit instantiation of %0 must occur at global scope
explicit instantiation of %0 not in a namespace enclosing %1
explicit instantiation of %q0 must occur in namespace %1
field %0 is uninitialized when used here
class with destructor marked '%select{final|sealed}0' cannot be inherited from
enumeration value %0 is out of range of flags in enumeration type %1
magnitude of floating-point constant too large for type %0; maximum is %1
magnitude of floating-point constant too small for type %0; minimum is %1
'begin' and 'end' returning different types (%0 and %1) is incompatible with C++ standards before C++17
loop variable %0 %diff{of type $ binds to a temporary constructed from type $|binds to a temporary constructed from a different type}1,2
loop variable %0 creates a copy from type %1
loop variable %0 binds to a temporary value produced by a range of type %1
using '%%P' format specifier without precision
%select{values of type|enum values with underlying type}2 '%0' should not be used as format arguments; add an explicit cast to %1 instead
%select{values of type|enum values with underlying type}2 '%0' should not be used as format arguments; add an explicit cast to %1 instead
using '%0' format specifier, but argument has boolean value
format specifies type %0 but the argument has %select{type|underlying type}2 %1
format specifies type %0 but the argument has %select{type|underlying type}2 %1
format specifies type %0 but the argument has %select{type|underlying type}2 %1
using '%0' format specifier annotation outside of os_log()/os_trace()
invalid conversion specifier '%0'
invalid position specified for %select{field width|field precision}0
'%0' %select{length modifier|conversion specifier}1 is not supported by ISO C
using length modifier '%0' with conversion specifier '%1' is not supported by ISO C
length modifier '%0' results in undefined behavior or no effect with '%1' conversion specifier
'%0' will always overflow; destination buffer has size %1, but format string expands to at least %2
'%0' will always overflow; destination buffer has size %1, but size argument is %2
'%0' size argument is too large; destination buffer has size %1, but size argument is %2
redefinition of forward class %0 of a typedef name of an object type is ignored
calling '%0' with a nonzero argument is unsafe
attempt to call %0 on non-heap %select{object %2|object: block expression|object: lambda-to-function-pointer conversion}1
cannot call function '%1' while %0 '%2' is held
calling function %1 requires holding %0 %select{'%2'|'%2' exclusively}3
calling function %1 requires holding %0 %select{'%2'|'%2' exclusively}3
calling function %0 requires negative capability '%1'
instantiation of function %q0 required here, but no definition is available
%0 overrides a member function but is not marked 'override'
GCC does not allow the %0 attribute to be written on a type
passing variable %1 by reference requires holding %0 %select{'%2'|'%2' exclusively}3
%select{instance variable|property}2 with %0 attribute must be an object type (invalid %1)
assigning %select{field|instance variable}0 to itself
inheritance model ignored on %select{primary template|partial specialization}0
'objc_externally_retained' can only be applied to local variables %select{of retainable type|with strong ownership}0
implicit truncation from %2 to bit-field changes value from %0 to %1
initialization of pointer of type %0 to null from a constant boolean expression
implicit conversion discards imaginary component: %0 to %1
implicit conversion from constant value %0 to 'BOOL'; the only well defined values for 'BOOL' are YES and NO
implicit conversion from enumeration type %0 to different enumeration type %1
implicit conversion increases floating-point precision: %0 to %1
implicit conversion from %0 cannot fit within the range of values for %1
implicit conversion turns floating-point number into integer: %0 to %1
implicit conversion loses floating-point precision: %0 to %1
implicit conversion when assigning computation result loses floating-point precision: %0 to %1
implicit conversion from %0 to %1 changes value from %2 to %3
implicit conversion of out of range value from %0 to %1 is undefined
implicit conversion from %0 to %1 changes non-zero value from %2 to %3
implicit conversion from floating-point type %0 to 'BOOL'
implicit conversion turns floating-point number into bool: %0 to %1
implicit conversion from integral type %0 to 'BOOL'
implicit conversion loses integer precision: %0 to %1
implicit conversion from %0 to %1 may lose precision
implicit conversion from %2 to %3 changes value from %0 to %1
implicit conversion loses integer precision: %0 to %1
implicit conversion from %2 to %3 changes value from %0 to %1
implicit conversion changes signedness: %0 to %1
operand of ? changes signedness: %0 to %1
implicit conversion from %0 to %1 changes value from %2 to %3
implicit conversion of out of range value from %0 to %1 is undefined
implicit conversion of %select{NULL|nullptr}0 constant to %1
address of%select{| function| array}0 '%1' will always evaluate to 'true'
implicit conversion turns string literal into bool: %0 to %1
implicit conversion turns vector to scalar: %0 to %1
class property %0 requires method %1 to be defined - use @dynamic or provide a method implementation in this class implementation
class property %0 requires method %1 to be defined - use @dynamic or provide a method implementation in this category
default assign attribute on property %0 which implements NSCopying protocol is not appropriate with -fobjc-gc[-only]
declaration of built-in function '%0' requires the declaration of the 'jmp_buf' type, commonly provided in the header <setjmp.h>.
declaration of built-in function '%1' requires inclusion of the header <%0>
implicit declaration of function %0
import %select{module|name}0 cannot be applied to a function with a definition
direct base %0 is inaccessible due to ambiguity:%1
%select{%diff{assigning to $ from incompatible type $|assigning to type from incompatible type}0,1|%diff{passing $ to parameter of incompatible type $|passing type to parameter of incompatible type}0,1|%diff{returning $ from a function with incompatible result type $|returning type from a function with incompatible result type}0,1|%diff{converting $ to incompatible type $|converting type to incompatible type}0,1|%diff{initializing $ with an expression of incompatible type $|initializing type with an expression of incompatible type}0,1|%diff{sending $ to parameter of incompatible type $|sending type to parameter of incompatible type}0,1|%diff{casting $ to incompatible type $|casting type to incompatible type}0,1}2
incompatible vector types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2
encoding of %0 type is incomplete because %1 component has unknown encoding
%sub{warn_destructor_marked_not_override_overriding}0
%sub{warn_function_marked_not_override_overriding}0
constant expression evaluates to %0 which cannot be narrowed to type %1 in C++11
type %0 cannot be narrowed to %1 in initializer list in C++11
non-constant-expression cannot be narrowed from type %0 to %1 in initializer list in C++11
initializing pointer member %0 with the stack address of %select{variable|parameter}2 %1
%select{field|base class}0 %1 will be initialized after %select{field|base}2 %3
initializer %select{partially |}0overrides prior initialization of this subobject
instance method %objcinstance0 not found (return type defaults to 'id')
instance method %objcinstance0 not found (return type defaults to 'id'); did you mean %objcinstance2?
instance method %0 found instead of class method %1
cast to %1 from smaller integer type %0
cast to %1 from smaller integer type %0
%select{MIPS|MSP430|RISC-V}0 'interrupt' attribute only applies to functions that have %select{no parameters|a 'void' return type}1
local declaration of %0 hides instance variable
ignored 'inline' attribute on kernel function %0
kernel function %0 is a member function; this may not be accepted by nvcc
converting the result of '<<' to a boolean always evaluates to %select{false|true}0
converting the result of '<<' to a boolean; did you mean '(%0) != 0'?
%0 '%1' is acquired exclusively and shared in the same scope
%0 '%1' is not held on every path through here
use of logical '%0' with constant operand
logical not is only applied to the left hand side of this %select{comparison|bitwise operator}0
'%0' is bound to current loop, GCC binds it to the enclosing loop
state of variable '%0' must match at the entry and exit of loop
taking the max of %select{a value and unsigned zero|unsigned zero and a value}0 is always equal to the other value
variable %0 may be uninitialized when %select{used here|captured by block}1
%0 may not respond to %1
extra qualification on member %0
size argument in %0 call is a comparison
%select{|overriding }4method %select{introduced after|deprecated before|obsoleted before}0 %select{the protocol method it implements|overridden method}4 on %1 (%2 vs. %3)
%select{|overriding }1method cannot be unavailable on %0 when %select{the protocol method it implements|its overridden method}1 is available
'delete%select{|[]}0' applied to a pointer that was allocated with 'new%select{[]|}0'; did you mean 'delete%select{[]|}0'?
import %select{module|name}0 (%1) does not match the import %select{module|name}0 (%2) of the previous declaration
nullability specifier %0 conflicts with existing specifier %1
%select{codeseg|section}0 does not match previous declaration
%plural{1:enumeration value %1 not handled in switch|2:enumeration values %1 and %2 not handled in switch|3:enumeration values %1, %2, and %3 not handled in switch|:%0 enumeration values not handled in switch: %1, %2, %3...}0
no case matching constant switch condition '%0'
missing field %0 initializer
no previous prototype for function %0
%0 availability is ignored without a valid 'SDKSettings.json' in the SDK
missing sentinel in %select{function call|method dispatch|block call}0
no previous extern declaration for non-static variable %0
comparison of integers of different signs: %0 and %1
modifying constructor parameter %0 that shadows a field of %1
multiple methods named %0 found
several methods with selector %0 of mismatched types are found for the @selector expression
extra qualification on member %0
array backing %select{initializer list subobject of the allocated object|the allocated initializer list}0 will be destroyed at the end of the full-expression
auto property synthesis will not synthesize property %0 because it is 'readwrite' but it will be synthesized 'readonly' via another property
auto property synthesis will not synthesize property %0 because it cannot share an ivar with another synthesized property
%select{struct|interface|union|class|enum}0 %1 does not declare any constructor to initialize its non-modifiable members
dynamic_cast will not work since RTTI data is disabled by %select{-fno-rtti-data|/GR-}0
typeid will not work since RTTI data is disabled by %select{-fno-rtti-data|/GR-}0
enums in the Microsoft ABI are signed integers by default; consider giving the enum %0 an unsigned underlying type to make this code portable
%0 '%1' is still held at the end of function
%0 attribute is ignored because there exists no call expression inside the statement
conflicting parameter types in declaration of %0: %1 vs %2
conflicting parameter types in implementation of %0: %1 vs %2
conflicting return type in declaration of %0: %1 vs %2
conflicting return type in implementation of %0: %1 vs %2
expression which evaluates to zero treated as a null pointer constant of type %0
cannot pass %select{non-POD|non-trivial}0 object of type %1 to variadic %select{function|block|method|constructor}2; expected type from format string was %3
%0 has virtual functions but non-virtual destructor
comparison of nonnull %select{function call|parameter}0 '%1' %select{not |}2equal to a null pointer is '%select{true|false}2' on first encounter
function %0 declared 'noreturn' should not return
use of unary operator that may be intended as compound assignment (%0=)
not enough variable arguments in %0 declaration to fit a sentinel
case value not in enumerated type %0
integer constant not in range of enumerated type %0
%0 attribute only applies to %select{Objective-C object|pointer|pointer-to-CF-pointer|pointer/reference-to-OSObject-pointer}1 parameters
%0 attribute only applies to %select{functions|methods|properties}1 that return %select{an Objective-C object|a pointer|a non-retainable pointer}2
overriding method has mismatched ns_returns_%select{not_retained|retained}0 attributes
comparison between NULL and non-pointer %select{(%1 and NULL)|(NULL and %1)}0
comparison of %select{address of|function|array}0 '%1' %select{not |}2equal to a null pointer is always %select{true|false}2
synthesized setter %0 for null_resettable property %1 does not handle nil
null returned from %select{function|method}0 that requires a non-null return value
nullability specifier %0 cannot be applied to non-pointer type %1; did you mean to apply the specifier to the %select{pointer|block pointer|member pointer|function pointer|member function pointer}2?
inferring '_Nonnull' for pointer type within %select{array|reference}0 is deprecated
implicit conversion from nullable pointer %0 to non-nullable pointer type %1
%select{pointer|block pointer|member pointer}0 is missing a nullability type specifier (_Nonnull, _Nullable, or _Null_unspecified)
string is ill-formed as UTF-8 and will become a null %0 when boxed
using %0 directive in %select{NSString|CFString}1 which is being passed as a formatting argument to the formatting %select{method|CFfunction}2
adding %0 to %1 might cause circular dependency in container
object of type %0 is not compatible with %select{array element type|dictionary key type|dictionary value type}1 %2
%0 attribute isn't implemented by this Objective-C runtime
direct attribute on property %0 ignored (not implemented by this Objective-C runtime)
method override for the designated initializer of the superclass %objcinstance0 not found
%0 bridges to %1, not %2
%0 cannot bridge to %1
direct comparison of %select{an array literal|a dictionary literal|a numeric literal|a boxed expression|}0 has undefined behavior
method possibly missing a [super %0] call
objc_precise_lifetime is not meaningful for %select{__unsafe_unretained|__autoreleasing}0 objects
using %0 with a literal is redundant
parameterized class %0 already conforms to the protocols listed; did you forget a '*'?
%0 attribute cannot be applied to %select{methods in protocols|dealloc}1
class %0 defined without specifying a base class
%0 is incompatible with selectors that return a %select{struct|union|vector}1 type
allocator with the 'thread' trait access has unspecified behavior on '%0' directive
score expressions in the OpenMP context selector need to be constant; %0 is not and will be ignored
zero linear step (%0 %select{|and other variables in clause }1should probably be const)
Type %0 is not trivially copyable and not guaranteed to be mapped correctly
array section %select{lower bound|length}0 is of type 'char'
allocate directive specifies %select{default|'%1'}0 allocator while previously used %select{default|'%3'}2
%0 attribute is deprecated and ignored in OpenCL version %1
passing non-generic address space pointer to %0 may cause dynamic conversion affecting performance
%0 should not return a null pointer unless it is declared 'throw()'%select{| or 'noexcept'}1
os_log() '%%n' format specifier is not allowed
result of comparison of %select{constant %0|true|false}1 with %select{expression of type %2|boolean expression}3 is always %4
type %0 requires %1 bytes of alignment and the default allocator only guarantees %2 bytes
overloaded operator %select{>>|<<}0 has higher precedence than comparison operator
%q0 hides overloaded virtual %select{function|functions}1
passing %0-byte aligned argument to %1-byte aligned parameter %2 of %3 may result in an unaligned pointer access
parameter '%0' not in expected state when the function returns: expected '%1', observed '%2'
argument not in expected state; expected '%0', observed '%1'
%0 is a large (%1 bytes) pass-by-value argument; pass it by reference instead ?
parentheses were disambiguated as redundant parentheses around declaration of variable named %0
passing object of class type %0 through variadic %select{function|block|method|constructor}1%select{|; did you mean to call '%3'?}2
taking the absolute value of %select{pointer|function|array}0 type %1 is suspicious
performing pointer arithmetic on a null pointer has undefined behavior%select{| if the offset is nonzero}0
comparing a pointer to a null character constant; did you mean to compare to %select{NULL|(void *)0}0?
dereference of type %1 that was reinterpret_cast from type %0 has undefined behavior
performing pointer subtraction with a null pointer %select{has|may have}0 undefined behavior
cast to smaller integer type %1 from %0
cast to smaller integer type %1 from %0
@selector expression formed with potentially direct selector %0
unused attribute %0 in '#pragma clang attribute push' region
#pragma options align=reset failed: %0
value of #pragma pack(show) == %0
#pragma %0(pop, ...) failed: %1
undeclared variable %0 used as an argument for '#pragma unused'
operator '?:' has lower precedence than '%0'; '%0' will be evaluated first
%0 has lower precedence than %1; %1 will be evaluated first
operator '?:' has lower precedence than '%0'; '%0' will be evaluated first
object format flags cannot be used with '%0' conversion specifier
'%select{*|.*}0' specified field %select{width|precision}0 is missing a matching 'int' argument
field %select{width|precision}0 should have type %1, but argument has type %2
flag '%0' is ignored when flag '%1' is present
more '%%' conversions than data arguments
'%0' is not a valid object format flag
flag '%0' results in undefined behavior with '%1' conversion specifier
%select{field width|precision}0 used with '%1' conversion specifier, resulting in undefined behavior
data argument position '%0' exceeds the number of data arguments (%1)
property %0 not found on object of type %1; did you mean to access property %2?
'%1' attribute on property %0 does not match the property inherited from %2
property access is using %0 method which is deprecated
getter name mismatch between property redeclaration (%1) and its original declaration (%0)
property type %0 is incompatible with type %1 inherited from %2
property %select{of type %1|with attribute '%1'|without attribute '%1'|with getter %1|with setter %1}0 was selected for synthesis
passing the value that %1 points to by reference requires holding %0 %select{'%2'|'%2' exclusively}3
the pointer incremented by %0 refers past the end of the array (that contains %1 element%s2)
the pointer incremented by %0 refers past the last possible element for an array in %1-bit address space containing %2-bit (%3-byte) elements (max possible %4 element%s5)
the pointer decremented by %0 refers before the beginning of the array
'%0' type qualifier%s1 on return type %plural{1:has|:have}1 no effect
attribute 'readonly' of property %0 restricts attribute 'readwrite' of property inherited from %1
receiver %0 is a forward class and corresponding @interface may not exist
receiver type %0 for instance message is a forward declaration
incompatible redeclaration of library function %0
%q0 redeclared without %1 attribute: previous %1 ignored
%q0 redeclared without 'dllimport' attribute: 'dllexport' attribute added
#pragma redefine_extname is applicable to external C declarations only; not applied to %select{function|variable}0 %1
redefinition of %0 will not be visible outside of this function
variable %0 is %select{decremented|incremented}1 both in the loop header and in the loop body
reference %0 is not yet bound to a value when used here
'reinterpret_cast' %select{from|to}3 class %0 %select{to|from}3 its %select{virtual base|base at non-zero offset}2 %1 behaves differently from 'static_cast'
method is expected to return an instance of its class type %diff{$, but is declared to return $|, but is declared to return different type}0,1
protocol method is expected to return an instance of the implementing class, but is declared to return %0
%select{remainder|division}0 by zero is undefined
identifier %0 is reserved because %select{<ERROR>|it starts with '_' at global scope|it starts with '__'|it starts with '_' followed by a capital letter|it contains '__'}1
returning %select{address of|reference to}0 local temporary object
%select{address of|reference to}0 stack memory associated with %select{local variable|parameter}2 %1 returned
non-void %select{function|method}1 %0 should return a value
return state set for an unconsumable type '%0'
return value not in expected state; expected '%0', observed '%1'
return value of %0 is a large (%1 bytes) pass-by-value object; pass it by reference instead ?
%0 has C-linkage specified, but returns user-defined type %1 which is incompatible with C
%0 has C-linkage specified, but returns incomplete type %1 which could be incompatible with C
instance method %0 is being used on 'Class' which is not in the root class
sampler initializer has invalid %0 bits
no closing ']' for '%%[' in scanf format string
second argument to 'va_arg' is of promotable type %0; this va_arg has undefined behavior because arguments will be promoted to %1
second argument to 'va_arg' is of non-POD type %0
second argument to 'va_arg' is of ARC ownership-qualified type %0
explicitly assigning value of variable of type %0 to itself
explicitly assigning value of variable of type %0 to itself
explicitly moving variable of type %0 to itself
property %0 requires method %1 to be defined - use @synthesize, @dynamic or provide a method implementation in this class implementation
property %0 requires method %1 to be defined - use @dynamic or provide a method implementation in this category
%select{parameter|non-static data member}3 %0 %select{|of %1 }3shadows member inherited from type %2
signed shift result (%0) requires %1 bits to represent, but %2 only has %3 bits
signed shift result (%0) sets the sign bit of the shift expression's type (%1) and becomes negative
signed bit-field %0 needs an extra bit to represent the largest positive enumerators of %1
sizeof on pointer operation will return size of %0 instead of %1
sizeof on array function parameter will return size of %0 instead of %1
'%0' call operates on objects of type %1 while the size is based on a different type %2
did you mean to %select{dereference the argument to 'sizeof' (and multiply it by the number of elements)|remove the addressof in the argument to 'sizeof' (and multiply it by the number of elements)|provide an explicit length}0?
argument to 'sizeof' in %0 call is the same pointer type %1 as the %select{destination|source}2; expected %3 or an explicit length
variable %0 is %select{used|captured}1 uninitialized whenever %select{'%3' condition is %select{true|false}4|'%3' loop %select{is entered|exits because its condition is false}4|'%3' loop %select{condition is true|exits because its condition is false}4|switch %3 is taken|its declaration is reached|%3 is called}2
'%0' ignored on this declaration
array argument is too small; %select{contains %0 elements|is of size %0}2, callee requires at least %1
static variable %0 is suspiciously used within its own initialization
multiple methods named %0 found
@selector expression formed with potentially direct selector %0
this %select{function declaration is not|block declaration is not|old-style function definition is not preceded by}0 a prototype
adding %0 to a string pointer does not append to the string
adding %0 to a string does not append to the string
result of comparison against %select{a string literal|@encode}0 is unspecified (use an explicit string comparison function instead)
size argument in %0 call appears to be size of the source; expected the size of the destination
%2 defined as %select{a struct|an interface|a class}0%select{| template}1 here but previously declared as %select{a struct|an interface|a class}3%select{| template}1; this is valid, but may result in linker errors under the Microsoft C++ ABI
%select{struct|interface|class}0%select{| template}1 %2 was previously declared as a %select{struct|interface|class}3%select{| template}1; this is valid, but may result in linker errors under the Microsoft C++ ABI
subtraction of pointers to type %0 of zero size has undefined behavior
%sub{warn_destructor_marked_not_override_overriding}0
%sub{warn_function_marked_not_override_overriding}0
%select{function|method}0 %1 could be declared with attribute 'noreturn'
field %0 can overwrite instance variable %1 with variable sized type %2 in superclass %3
%select{'size' argument to memset is '0'|setting buffer to a 'sizeof' expression}0; did you mean to transpose the last two arguments?
taking address of packed member %0 of class or structure %q1 may result in an unaligned pointer value
result of comparison of %select{constant %0|true|false}1 with %select{expression of type %2|boolean expression}3 is always %4
result of comparison of constant %0 with expression of type 'BOOL' is always %1, as the only well defined values for 'BOOL' are YES and NO
result of comparison of %select{%4|%sub{subst_int_range}1,2}0 %3 %select{%sub{subst_int_range}1,2|%4}0 is always %5
result of comparison %select{%3|%1}0 %2 %select{%1|%3}0 is always %4
overlapping comparisons always evaluate to %select{false|true}0
calling %0 is a violation of trusted computing base '%1'
non-type template argument with value '%0' converted to '%1' for unsigned template parameter of type %2
non-type template argument value '%0' truncated to '%1' for template parameter of type %2
dependent nested name specifier '%0' for friend template declaration is not supported; ignoring this friend declaration
dependent nested name specifier '%0' for friend class declaration is not supported; turning off access control for %1
'this' pointer cannot be null in well-defined C++ code; comparison may be assumed to always evaluate to %select{true|false}0
%0 attribute requires arguments whose type is annotated with 'capability' attribute; type here is %1
%0 attribute can only be applied in a context annotated with 'capability' attribute
%0 only applies to pointer types; type here is %1
ignoring %0 attribute because its argument is invalid
%0 attribute without capability arguments refers to 'this', but %1 isn't annotated with 'capability' or 'scoped_lockable' attribute
%0 attribute without capability arguments can only be applied to non-static methods of a class
%0 has a non-throwing exception specification but can still throw
%select{alignment|size}0 of field %1 (%2 bits) does not match the %select{alignment|size}0 of the first field in transparent union; transparent_union attribute ignored
first field of a transparent union cannot have %select{floating point|vector}0 type %1; transparent_union attribute ignored
'%0' only applies to %select{function|pointer|Objective-C object or block pointer}1 types; type here is %2
specified %0 type tag requires a null pointer
argument type %0 doesn't match specified %1 type tag %select{that requires %3|}2
'%0' qualifier on function type %1 has no effect
'%0' qualifier on function type %1 has unspecified behavior
ordered comparison of function pointers (%0 and %1)
'%0' qualifier on reference type %1 has no effect
vector operands do not have the same elements sizes (%0 and %1)
%0 may be unavailable because the receiver type is unknown
undeclared selector %0
undeclared selector %0; did you mean %1?
cannot find interface declaration for %0
cannot find interface declaration for %0; did you mean %1?
method definition for %0 not found
cannot find protocol definition for %0
inline function %q0 is not defined
%select{function|variable}0 %q1 has internal linkage but is not defined
reinterpret_cast from %0 to %1 has undefined behavior
%0 is only available on %1 %2 or newer
%0 is only available on %1 %2 or newer
__declspec attribute %0 is not supported
method %0 in protocol %1 not implemented
no method with selector %0 is implemented in this translation unit
block pointer variable %0 is %select{uninitialized|null}1 when captured by block
variable %0 is uninitialized when passed as a const reference argument here
variable %0 is uninitialized when used within its own initialization
reference %0 is not yet bound to a value when used within its own initialization
variable %0 is uninitialized when %select{used here|captured by block}1
isa trait '%0' is not known to the current target; verify the spelling or consider restricting the context selector with the 'arch' selector further
unknown sanitizer '%0' ignored
releasing %0 '%1' that was not held
releasing %0 '%1' using %select{shared|exclusive}2 access, expected %select{shared|exclusive}3 access
%select{function|variable}0 %1 is not needed and will not be emitted
member function %0 is not needed and will not be emitted
'static' function %0 declared in header file should be declared 'static inline'
multiple unsequenced modifications to %0
unsequenced modification and access to %0
taking the absolute value of unsigned type %0 has no effect
result of comparison of %select{%3|unsigned expression}0 %2 %select{unsigned expression|%3}0 is always %4
assigning value of signed enum type %1 to unsigned bit-field %0; negative enumerators of enum %1 will be converted to positive values
result of comparison of %select{%3|char expression}0 %2 %select{char expression|%3}0 is always %4, since char is interpreted as unsigned
result of comparison of %select{%3|unsigned enum expression}0 %2 %select{unsigned enum expression|%3}0 is always %4
sorry, lifetime extension of %select{temporary|backing array of initializer list}0 created by aggregate initialization using default member initializer is not supported; lifetime of %select{temporary|backing array}0 will end at the end of the full-expression
%select{unsupported|duplicate|unknown}0%select{| architecture| tune CPU}1 '%2' in the 'target' attribute string; 'target' attribute ignored
parameter %0 set but not used
variable %0 set but not used
ignoring return value of function declared with %0 attribute
%select{equality|inequality|relational|three-way}0 comparison result unused
unused variable %0
ignoring temporary created by a constructor declared with %0 attribute
ignoring temporary created by a constructor declared with %0 attribute: %1
unused exception parameter %0
unused function %0
unused label %0
lambda capture %0 is not %select{used|required to be captured for this use}1
unused %select{typedef|type alias}0 %1
unused member function %0
unused parameter %0
private field %0 is not used
ivar %0 which backs the property is not referenced in this property's accessor
ignoring return value of function declared with %0 attribute
ignoring return value of function declared with %0 attribute: %1
unused %select{function|variable}0 template %1
unused variable %0
invalid invocation of method '%0' on object '%1' while it is in the '%2' state
invalid invocation of method '%0' on a temporary object while it is in the '%1' state
%0 was marked unused but was used
user-defined literal suffixes not starting with '_' are reserved%select{; no literal will invoke this operator|}0
passing %select{an object that undergoes default argument promotion|an object of reference type|a parameter declared with the 'register' keyword}0 to 'va_start' has undefined behavior
%select{reading|writing}1 the value pointed to by %0 requires holding %select{any mutex|any mutex exclusively}1
%select{reading|writing}3 the value pointed to by %1 requires holding %0 %select{'%2'|'%2' exclusively}3
%select{reading|writing}3 the value pointed to by %1 requires holding %0 %select{'%2'|'%2' exclusively}3
instantiation of variable %q0 required here, but no definition is available
%select{reading|writing}1 variable %0 requires holding %select{any mutex|any mutex exclusively}1
%select{reading|writing}3 variable %1 requires holding %0 %select{'%2'|'%2' exclusively}3
%select{reading|writing}3 variable %1 requires holding %0 %select{'%2'|'%2' exclusively}3
field %0 with variable sized type %1 is not visible to subclasses and can conflict with their instance variables
variable%select{s| %1|s %1 and %2|s %1, %2, and %3|s %1, %2, %3, and %4}0 used in loop condition not modified in loop body
defaulted move assignment operator of %0 will move assign virtual base class %1 multiple times
cast to smaller integer type %1 from %0
cast to smaller integer type %1 from %0
weak identifier %0 never declared
an already-declared variable is made a weak_import declaration %0
explicit template instantiation %0 will emit a vtable in every translation unit
%0 has no out-of-line virtual method definitions; its vtable will be emitted in every translation unit
using %select{integer|floating point|complex}1 absolute value function %0 when argument is of %select{integer|floating point|complex}2 type
result of '%0' is %1; did you mean exponentiation?
result of '%0' is %1; did you mean '%2'?
result of '%0' is %1; did you mean '%2' (%3)?
%select{|empty }0%select{struct|union}1 has size 0 in C, %select{size 1|non-zero size}2 in C++
%select{|empty }0%select{struct|union}1 has size 0 in C, %select{size 1|non-zero size}2 in C++
